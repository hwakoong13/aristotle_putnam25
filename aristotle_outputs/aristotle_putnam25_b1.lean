/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a60740c5-f81e-48a0-8338-8f923970c557
-/

/-
We prove that if every monochromatic non-collinear triple has a monochromatic circumcenter, then the plane is monochromatic.
The proof proceeds by contradiction. If there are two points of different colors, we construct a configuration of circles that forces a contradiction.
Key lemmas include:
- `distinct_points_on_sphere_not_collinear`: Three distinct points on a sphere are not collinear.
- `circle_almost_monochromatic`: A circle centered at a point of color c contains at most 2 points of color != c.
- `range_dist_from_point_to_circle`: The range of distances from a point to a circle is an interval.
- `exists_common_distance_avoiding_finite`: We can find a radius avoiding a finite set of bad distances.
- `monochromatic_plane_contradiction`: The existence of two points of different colors leads to a contradiction.
- `monochromatic_plane_final`: The main theorem.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Three distinct points on a sphere of positive radius are not collinear.
-/
open EuclideanGeometry Affine Module

lemma distinct_points_on_sphere_not_collinear {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  (X : P) (r : ℝ) (hr : r > 0) (A B C : P)
  (hA : dist X A = r) (hB : dist X B = r) (hC : dist X C = r)
  (hAB : A ≠ B) (hAC : A ≠ C) (hBC : B ≠ C) :
  ¬Collinear ℝ {A, B, C} := by
    rw [ collinear_iff_exists_forall_eq_smul_vadd ] at * ; aesop;
    simp_all +decide [ dist_eq_norm_vsub, norm_smul ];
    -- By the properties of the inner product and the norm, we can simplify the equations.
    have h_simp : ‖X -ᵥ x‖^2 - 2 * x_2 * inner ℝ (X -ᵥ x) x_1 + x_2^2 * ‖x_1‖^2 = ‖X -ᵥ x‖^2 - 2 * x_3 * inner ℝ (X -ᵥ x) x_1 + x_3^2 * ‖x_1‖^2 ∧ ‖X -ᵥ x‖^2 - 2 * x_2 * inner ℝ (X -ᵥ x) x_1 + x_2^2 * ‖x_1‖^2 = ‖X -ᵥ x‖^2 - 2 * x_4 * inner ℝ (X -ᵥ x) x_1 + x_4^2 * ‖x_1‖^2 := by
      have h_simp : ∀ (t : ℝ), ‖X -ᵥ (t • x_1 +ᵥ x)‖^2 = ‖X -ᵥ x‖^2 - 2 * t * inner ℝ (X -ᵥ x) x_1 + t^2 * ‖x_1‖^2 := by
        intro t; rw [ show X -ᵥ ( t • x_1 +ᵥ x ) = ( X -ᵥ x ) - t • x_1 by exact? ] ; rw [ @norm_sub_sq ℝ ] ; ring;
        simp +decide [ norm_smul, inner_smul_right ];
        rw [ mul_pow, sq_abs ];
      exact ⟨ by rw [ ← h_simp x_2, ← h_simp x_3, hA, hB ], by rw [ ← h_simp x_2, ← h_simp x_4, hA ] ⟩;
    -- Since $x_2 \neq x_3$, we can divide both sides of the equation by $(x_2 - x_3)$.
    have h_div : -2 * inner ℝ (X -ᵥ x) x_1 + (x_2 + x_3) * ‖x_1‖^2 = 0 := by
      exact mul_left_cancel₀ ( sub_ne_zero_of_ne ( show x_2 ≠ x_3 from fun h => hAB <| by rw [ h ] ) ) <| by linarith;
    -- Since $x_2 \neq x_4$, we can divide both sides of the equation by $(x_2 - x_4)$.
    have h_div2 : -2 * inner ℝ (X -ᵥ x) x_1 + (x_2 + x_4) * ‖x_1‖^2 = 0 := by
      exact mul_left_cancel₀ ( sub_ne_zero_of_ne ( show x_2 ≠ x_4 by aesop ) ) ( by linarith );
    simp_all +decide [ add_eq_zero_iff_eq_neg ];
    aesop

/-
If there are 3 distinct points on a circle of color different from the center, we get a contradiction.
-/
open EuclideanGeometry Affine Module

noncomputable def circumcenterTriple {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  (A B C : P) (h : ¬Collinear ℝ {A, B, C}) : P :=
  (Simplex.mk ![A, B, C] (affineIndependent_iff_not_collinear_set.mpr h)).circumcenter

lemma three_points_on_circle_contradiction {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  [FiniteDimensional ℝ V] (hdim : finrank ℝ V = 2)
  (color : P → Bool)
  (cond : ∀ (A B C : P) (h : ¬Collinear ℝ {A, B, C}),
    color A = color B → color B = color C →
    color (circumcenterTriple A B C h) = color A)
  (X : P) (r : ℝ) (hr : r > 0)
  (A B C : P) (hA : dist X A = r) (hB : dist X B = r) (hC : dist X C = r)
  (hAB : A ≠ B) (hAC : A ≠ C) (hBC : B ≠ C)
  (hColorA : color A ≠ color X) (hColorB : color B ≠ color X) (hColorC : color C ≠ color X)
  (hColorAB : color A = color B) (hColorBC : color B = color C) : False := by
    -- By `distinct_points_on_sphere_not_collinear`, A, B, C are not collinear.
    have h_not_collinear : ¬Collinear ℝ {A, B, C} := by
      exact?;
    -- Since `dist X A = dist X B = dist X C = r`, X is equidistant from A, B, C.
    have hX_eq_dist : X = circumcenterTriple A B C h_not_collinear := by
      rw [ eq_comm, circumcenterTriple ];
      simp_all +decide [ dist_eq_norm_vsub ];
      have h_circumcenter : ∀ x : P, ‖x -ᵥ A‖ = ‖x -ᵥ B‖ ∧ ‖x -ᵥ B‖ = ‖x -ᵥ C‖ → x = X := by
        intro x hx;
        have h_circumcenter : ∀ x : V, ‖x + (X -ᵥ A)‖ = ‖x + (X -ᵥ B)‖ ∧ ‖x + (X -ᵥ B)‖ = ‖x + (X -ᵥ C)‖ → x = 0 := by
          intro x hx
          have h_circumcenter : ∀ x : V, ‖x + (X -ᵥ A)‖ = ‖x + (X -ᵥ B)‖ ∧ ‖x + (X -ᵥ B)‖ = ‖x + (X -ᵥ C)‖ → x = 0 := by
            intro x hx
            have h_eq : inner ℝ x (X -ᵥ A - (X -ᵥ B)) = 0 ∧ inner ℝ x (X -ᵥ B - (X -ᵥ C)) = 0 := by
              constructor <;> rw [ ← sq_eq_sq₀ ( norm_nonneg _ ) ( norm_nonneg _ ) ] at hx <;> simp_all +decide [ norm_add_sq_real, norm_sub_sq_real ];
              · rw [ show B -ᵥ A = ( X -ᵥ A ) - ( X -ᵥ B ) by simp +decide [ vsub_sub_vsub_cancel_left ], inner_sub_right ] ; aesop;
              · have := norm_add_sq_real x ( X -ᵥ B ) ; have := norm_add_sq_real x ( X -ᵥ C ) ; simp_all +decide [ norm_eq_sqrt_real_inner ];
                rw [ show C -ᵥ B = ( X -ᵥ B ) - ( X -ᵥ C ) by simp +decide [ vsub_sub_vsub_cancel_left ], inner_sub_right ] ; simp_all +decide [ inner_sub_left, inner_sub_right ]
            have h_lin_indep : LinearIndependent ℝ ![X -ᵥ A - (X -ᵥ B), X -ᵥ B - (X -ᵥ C)] := by
              rw [ linearIndependent_fin2 ];
              simp_all +decide [ sub_eq_iff_eq_add ];
              refine' ⟨ Ne.symm hBC, fun a ha => h_not_collinear _ ⟩;
              rw [ collinear_iff_exists_forall_eq_smul_vadd ];
              use B, C -ᵥ B;
              simp +decide [ ← ha ];
              exact ⟨ ⟨ -a, by simp +decide [ ha, neg_smul ] ⟩, ⟨ 0, by simp +decide ⟩, ⟨ 1, by simp +decide ⟩ ⟩;
            have h_lin_indep : Submodule.span ℝ (Set.range ![X -ᵥ A - (X -ᵥ B), X -ᵥ B - (X -ᵥ C)]) = ⊤ := by
              refine' Submodule.eq_top_of_finrank_eq _;
              rw [ finrank_span_eq_card ] <;> aesop;
            have h_lin_indep : ∀ y : V, inner ℝ x y = 0 := by
              intro y
              have h_y : y ∈ Submodule.span ℝ (Set.range ![X -ᵥ A - (X -ᵥ B), X -ᵥ B - (X -ᵥ C)]) := by
                aesop;
              rw [ Submodule.mem_span_range_iff_exists_fun ] at h_y;
              obtain ⟨ c, rfl ⟩ := h_y; simp +decide [ Fin.sum_univ_succ, h_eq ] ;
              simp_all +decide [ inner_add_right, inner_smul_right ];
            exact norm_eq_zero.mp ( by simpa using h_lin_indep x );
          exact h_circumcenter x hx;
        specialize h_circumcenter ( x -ᵥ X ) ; simp_all +decide [ vsub_sub_vsub_cancel_left ];
      apply h_circumcenter;
      have h_circumcenter : ∀ (s : Simplex ℝ P 2), ‖Simplex.circumcenter s -ᵥ s.points 0‖ = ‖Simplex.circumcenter s -ᵥ s.points 1‖ ∧ ‖Simplex.circumcenter s -ᵥ s.points 1‖ = ‖Simplex.circumcenter s -ᵥ s.points 2‖ := by
        intro s;
        have := s.dist_circumcenter_eq_circumradius;
        simp_all +decide [ dist_eq_norm_vsub', norm_sub_rev ];
      exact h_circumcenter _;
    aesop

/-
A circle centered at a point X of color c contains at most 2 points of color != c.
-/
open EuclideanGeometry Affine Module

lemma circle_almost_monochromatic {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  [FiniteDimensional ℝ V] (hdim : finrank ℝ V = 2)
  (color : P → Bool)
  (cond : ∀ (A B C : P) (h : ¬Collinear ℝ {A, B, C}),
    color A = color B → color B = color C →
    color (circumcenterTriple A B C h) = color A)
  (X : P) (r : ℝ) (hr : r > 0) :
  ∀ (s : Finset P), (∀ Y ∈ s, dist X Y = r ∧ color Y ≠ color X) → s.card ≤ 2 := by
    intro s hs;
    by_contra h_contra;
    -- Let's choose any three distinct points A, B, C in s.
    obtain ⟨A, B, C, hA, hB, hC, h_distinct⟩ : ∃ A B C : P, A ∈ s ∧ B ∈ s ∧ C ∈ s ∧ A ≠ B ∧ A ≠ C ∧ B ≠ C := by
      rcases Finset.two_lt_card.1 ( lt_of_not_ge h_contra ) with ⟨ A, hA, B, hB, hAB ⟩ ; use A, B ; aesop;
    -- Since A, B, C ∈ s, they satisfy `dist X A = r`, `dist X B = r`, `dist X C = r` and `color A ≠ color X`, `color B ≠ color X`, `color C ≠ color X`.
    obtain ⟨hA_dist, hA_color⟩ := hs A hA
    obtain ⟨hB_dist, hB_color⟩ := hs B hB
    obtain ⟨hC_dist, hC_color⟩ := hs C hC;
    -- Let `c' = color A`. Since `color A` is a Bool, and `color A ≠ color X`, `color A` is determined by `color X`.
    -- Specifically, `color A = !color X`.
    -- Similarly, `color B = !color X` and `color C = !color X`.
    -- So `color A = color B` and `color B = color C`.
    have h_color_eq : color A = color B ∧ color B = color C := by
      cases h : color X <;> aesop;
    -- Now we can apply `three_points_on_circle_contradiction` to A, B, C.
    apply three_points_on_circle_contradiction hdim color cond X r hr A B C hA_dist hB_dist hC_dist h_distinct.left h_distinct.right.left h_distinct.right.right hA_color hB_color hC_color h_color_eq.left h_color_eq.right

/-
The set of distances from a point Q to a circle centered at C with radius r is the interval [|dist(C, Q) - r|, dist(C, Q) + r].
-/
open EuclideanGeometry Affine Module

lemma range_dist_from_point_to_circle {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  [FiniteDimensional ℝ V] (hdim : finrank ℝ V = 2)
  (C Q : P) (r : ℝ) (hr : r > 0) :
  Set.image (dist Q) (Metric.sphere C r) = Set.Icc (|dist C Q - r|) (dist C Q + r) := by
    -- The image of the sphere under the distance function is an interval.
    have h_image_interval : IsConnected (Set.image (fun x : P => dist Q x) (Metric.sphere C r)) := by
      apply_rules [ IsConnected.image, isConnected_sphere ];
      · have h_sphere_connected : IsConnected (Metric.sphere (0 : V) r) := by
          apply_rules [ isPreconnected_sphere, isConnected_sphere ];
          · rw [ ← Module.finrank_eq_rank ] ; aesop;
          · positivity;
        have h_sphere_connected : IsConnected (Set.image (fun v : V => v +ᵥ C) (Metric.sphere (0 : V) r)) := by
          exact h_sphere_connected.image _ ( Continuous.continuousOn ( by continuity ) );
        convert h_sphere_connected using 1;
        ext; simp [Metric.sphere];
        aesop;
        exact ⟨ ( x -ᵥ C ), by simp +decide [ dist_eq_norm_vsub ], by simp +decide ⟩;
      · exact Continuous.continuousOn ( continuous_const.dist continuous_id' );
    have h_image_bounds : ∀ x ∈ Metric.sphere C r, |dist C Q - r| ≤ dist Q x ∧ dist Q x ≤ dist C Q + r := by
      aesop;
      · rw [ abs_sub_le_iff ] ; constructor <;> linarith [ dist_triangle C Q x, dist_triangle_left C Q x, dist_triangle_right C Q x, dist_comm C Q, dist_comm x C ] ;
      · rw [ dist_comm C Q ];
        exact dist_triangle_right _ _ _;
    -- To show that the image contains the endpoints, we use the fact that there exist points X and Y on the sphere such that dist Q X = |dist C Q - r| and dist Q Y = dist C Q + r.
    have h_endpoints : ∃ X Y : P, X ∈ Metric.sphere C r ∧ dist Q X = |dist C Q - r| ∧ Y ∈ Metric.sphere C r ∧ dist Q Y = dist C Q + r := by
      have h_endpoints : ∃ X Y : V, ‖X‖ = r ∧ ‖Q -ᵥ C - X‖ = |dist C Q - r| ∧ ‖Y‖ = r ∧ ‖Q -ᵥ C - Y‖ = dist C Q + r := by
        -- Let $v$ be a unit vector in the direction of $Q - C$.
        obtain ⟨v, hv⟩ : ∃ v : V, ‖v‖ = 1 ∧ Q -ᵥ C = dist C Q • v := by
          by_cases h : Q = C <;> simp_all +decide [ dist_eq_norm', norm_smul ];
          · have := Module.finrank_pos_iff.mp ( by linarith );
            obtain ⟨ v, hv ⟩ := exists_ne ( 0 : V ) ; exact ⟨ ‖v‖⁻¹ • v, by simp +decide [ norm_smul, hv ] ⟩ ;
          · use (1 / dist C Q) • (Q -ᵥ C);
            simp +decide [ norm_smul, dist_comm C Q, h ];
            rw [ inv_mul_eq_div, div_eq_iff ] <;> simp +decide [ dist_eq_norm', h ];
            exact?;
        refine' ⟨ r • v, -r • v, _, _, _, _ ⟩ <;> simp +decide [ hv, norm_smul, hr.le ];
        · rw [ ← sub_smul, norm_smul, hv.1, Real.norm_eq_abs ];
          rw [ mul_one ];
        · rw [ ← add_smul, norm_smul, Real.norm_of_nonneg ( add_nonneg ( dist_nonneg ) hr.le ), hv.1, mul_one ];
      norm_num +zetaDelta at *;
      obtain ⟨ X, hX₁, hX₂, Y, hY₁, hY₂ ⟩ := h_endpoints;
      refine' ⟨ ( X : V ) +ᵥ C, _, _, ( Y : V ) +ᵥ C, _, _ ⟩ <;> simp +decide [ *, dist_eq_norm_vsub ];
      · convert hX₂ using 1;
        · rw [ vsub_vadd_eq_vsub_sub ];
        · rw [ dist_eq_norm_vsub ];
      · convert hY₂ using 1;
        · rw [ vsub_vadd_eq_vsub_sub ];
        · rw [ dist_eq_norm_vsub ];
    refine' Set.Subset.antisymm _ _;
    · exact Set.image_subset_iff.2 h_image_bounds;
    · intro x hx;
      rcases h_endpoints with ⟨ X, Y, hX, hX', hY, hY' ⟩ ; exact h_image_interval.Icc_subset ( Set.mem_image_of_mem _ hX ) ( Set.mem_image_of_mem _ hY ) ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩

/-
Given a positive d and a finite set D, there is a rho in the intersection of [0, 2d], [0.1d, 2.1d], and [0.2d, 2.2d] that is not in D.
-/
lemma exists_common_distance_avoiding_finite (d : ℝ) (hd : d > 0) (D : Set ℝ) (hD : D.Finite) :
  ∃ ρ, ρ ∉ D ∧
       ρ ∈ Set.Icc 0 (2 * d) ∧
       ρ ∈ Set.Icc (0.1 * d) (2.1 * d) ∧
       ρ ∈ Set.Icc (0.2 * d) (2.2 * d) := by
         by_contra h_contra;
         -- This implies that every point in the interval [0.2d, 2d] is in D.
         have h_all_in_D : ∀ x ∈ Set.Icc (0.2 * d) (2 * d), x ∈ D := by
           exact fun x hx => Classical.not_not.1 fun hx' => h_contra ⟨ x, hx', ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩, ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩, ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩ ⟩;
         exact hD.not_infinite <| Set.Icc_infinite ( by linarith ) |> Set.Infinite.mono h_all_in_D

open scoped Pointwise

/-
All points of the plane are the same color.
-/
open EuclideanGeometry Affine Module

lemma monochromatic_plane {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]
  [FiniteDimensional ℝ V] (hdim : finrank ℝ V = 2)
  (color : P → Bool)
  (cond : ∀ (A B C : P) (h : ¬Collinear ℝ {A, B, C}),
    color A = color B → color B = color C →
    color (circumcenterTriple A B C h) = color A) :
  ∀ (p1 p2 : P), color p1 = color p2 := by
    intro p1 p2;
    -- Let $d = dist(p1, p2)$. Since colors are different, $p1 \ne p2$, so $d > 0$.
    by_cases h_eq : color p1 = color p2;
    · exact h_eq;
    · -- Let $d = dist(p1, p2)$. Since colors are different, $p1 \ne p2$, so $d > 0$. Assume without loss of generality that $p1$ is Red and $p2$ is Green.
      set d := dist p1 p2 with hd
      have hd_pos : 0 < d := by
        exact dist_pos.mpr ( by aesop )
      wlog h_red : color p1 = true ∧ color p2 = false generalizing p1 p2;
      · cases h : color p1 <;> cases h' : color p2 <;> simp_all +decide;
        specialize this p2 p1 ; aesop;
      · -- Consider 3 disjoint circles around p1 with radii $r_1 = d$, $r_2 = 1.1d$, $r_3 = 1.2d$.
        set r1 := d
        set r2 := 1.1 * d
        set r3 := 1.2 * d;
        -- By `circle_almost_monochromatic`, each circle $C_i$ contains at most 2 Green points.
        -- Let $B_i$ be the set of Green points on $C_i$. $B_i$ is finite.
        -- Let $D_i = \{ dist(p2, x) | x \in B_i \}$. $D_i$ is finite.
        -- The range of distances from $p2$ to $C_i$ is an interval $J_i$.
        -- By `range_dist_from_point_to_circle`:
        -- $J_1 = [0, 2d]$.
        -- $J_2 = [0.1d, 2.1d]$.
        -- $J_3 = [0.2d, 2.2d]$.
        -- Let $D = D_1 \cup D_2 \cup D_3$. $D$ is finite.
        -- By `exists_common_distance_avoiding_finite`, there exists $\rho \in J_1 \cap J_2 \cap J_3$ such that $\rho \notin D$.
        obtain ⟨ρ, hρ⟩ : ∃ ρ, ρ ∉ (Set.image (dist p2) (Metric.sphere p1 r1 ∩ {p | color p = false})) ∪ (Set.image (dist p2) (Metric.sphere p1 r2 ∩ {p | color p = false})) ∪ (Set.image (dist p2) (Metric.sphere p1 r3 ∩ {p | color p = false})) ∧ ρ ∈ Set.Icc 0 (2 * d) ∧ ρ ∈ Set.Icc (0.1 * d) (2.1 * d) ∧ ρ ∈ Set.Icc (0.2 * d) (2.2 * d) := by
          have h_finite : Set.Finite (Set.image (dist p2) (Metric.sphere p1 r1 ∩ {p | color p = false})) ∧ Set.Finite (Set.image (dist p2) (Metric.sphere p1 r2 ∩ {p | color p = false})) ∧ Set.Finite (Set.image (dist p2) (Metric.sphere p1 r3 ∩ {p | color p = false})) := by
            have h_finite : ∀ r > 0, Set.Finite (Metric.sphere p1 r ∩ {p | color p = false}) := by
              intro r hr;
              have := circle_almost_monochromatic hdim color cond p1 r hr;
              contrapose! this;
              obtain ⟨ s, hs ⟩ := Set.Infinite.exists_subset_card_eq this 3;
              exact ⟨ s, fun Y hy => ⟨ by simpa [ dist_comm ] using hs.1 hy |>.1, by simpa [ h_red ] using hs.1 hy |>.2 ⟩, by linarith ⟩;
            exact ⟨ Set.Finite.image _ ( h_finite _ hd_pos ), Set.Finite.image _ ( h_finite _ ( mul_pos ( by norm_num ) hd_pos ) ), Set.Finite.image _ ( h_finite _ ( mul_pos ( by norm_num ) hd_pos ) ) ⟩;
          apply exists_common_distance_avoiding_finite;
          · exact hd_pos;
          · exact Set.Finite.union ( Set.Finite.union h_finite.1 h_finite.2.1 ) h_finite.2.2;
        -- Since $\rho \in J_i$, there exists $x_i \in C_i$ such that $dist(p2, x_i) = \rho$.
        obtain ⟨x1, hx1⟩ : ∃ x1 ∈ Metric.sphere p1 r1, dist p2 x1 = ρ := by
          have := range_dist_from_point_to_circle hdim p1 p2 r1 hd_pos;
          simp_all +decide [ abs_of_nonneg ];
          exact this.symm.subset ⟨ by linarith, by linarith ⟩ |> fun ⟨ x, hx, hx' ⟩ => ⟨ x, by simpa [ dist_comm ] using hx, hx' ⟩
        obtain ⟨x2, hx2⟩ : ∃ x2 ∈ Metric.sphere p1 r2, dist p2 x2 = ρ := by
          have := range_dist_from_point_to_circle hdim p1 p2 r2 ( by positivity );
          simp +zetaDelta at *;
          rw [ Set.ext_iff ] at this;
          exact this ρ |>.2 ⟨ by cases abs_cases ( Dist.dist p1 p2 - 1.1 * Dist.dist p1 p2 ) <;> linarith, by cases abs_cases ( Dist.dist p1 p2 - 1.1 * Dist.dist p1 p2 ) <;> linarith ⟩ |> fun ⟨ x2, hx2, hx2' ⟩ => ⟨ x2, by simpa [ dist_comm ] using hx2, hx2' ⟩
        obtain ⟨x3, hx3⟩ : ∃ x3 ∈ Metric.sphere p1 r3, dist p2 x3 = ρ := by
          have := range_dist_from_point_to_circle hdim p1 p2 r3 ( by positivity );
          norm_num +zetaDelta at *;
          rw [ Set.ext_iff ] at this;
          exact Exists.imp ( by aesop ) ( this ρ |>.2 ⟨ by cases abs_cases ( Dist.dist p1 p2 - 6 / 5 * Dist.dist p1 p2 ) <;> linarith, by cases abs_cases ( Dist.dist p1 p2 - 6 / 5 * Dist.dist p1 p2 ) <;> linarith ⟩ );
        -- Since $\rho \notin D_i$, $x_i \notin B_i$, so $x_i$ is Red.
        have hx1_red : color x1 = true := by
          contrapose! hρ; aesop;
        have hx2_red : color x2 = true := by
          grind +ring
        have hx3_red : color x3 = true := by
          grind;
        -- Since $r_i$ are distinct, $x_1, x_2, x_3$ are distinct.
        have hx_distinct : x1 ≠ x2 ∧ x1 ≠ x3 ∧ x2 ≠ x3 := by
          norm_num +zetaDelta at *;
          exact ⟨ by rintro rfl; linarith [ dist_pos.mpr hd_pos ], by rintro rfl; linarith [ dist_pos.mpr hd_pos ], by rintro rfl; linarith [ dist_pos.mpr hd_pos ] ⟩;
        -- Since $\rho \ge 0.2d > 0$, the radius is positive.
        have hρ_pos : 0 < ρ := by
          exact lt_of_lt_of_le ( by positivity ) hρ.2.2.1.1;
        -- Apply `three_points_on_circle_contradiction` to p2 and $x_1, x_2, x_3$.
        have := three_points_on_circle_contradiction hdim color cond p2 ρ hρ_pos x1 x2 x3;
        aesop
