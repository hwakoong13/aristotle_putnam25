/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0c5d7c7b-e9c7-4d35-8e88-882a8437caed
-/

/-
We determine the largest real constant $r$ such that there exists a function $g:\mathbb{N} \to \mathbb{N}$ satisfying $g(n+1) - g(n) \ge (g(g(n)))^r$. We prove that $r=1/4$ is the largest such constant. We first show that $g(n)=n^2$ satisfies the condition for $r=1/4$. Then we show that for any $r > 1/4$, no such function exists, by deriving a contradiction from the super-exponential growth of such a function.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Definition of the property that a function g exists satisfying the condition for a given r.
-/
def ExistsFunction (r : ℝ) : Prop :=
  ∃ g : PNat → PNat, ∀ n : PNat, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r

/-
The constant 1/4 satisfies the condition, witnessed by the function g(n) = n^2.
-/
theorem exists_function_one_quarter : ExistsFunction (1 / 4) := by
  -- Let's define the function g as g(n) = n^2.
  use fun n : PNat => ⟨n.val^2, by norm_num⟩;
  -- Simplifying the inequality.
  intro n
  simp;
  ring_nf;
  rw [ ← Real.rpow_natCast, ← Real.rpow_mul ] <;> norm_num ; nlinarith [ show ( n : ℝ ) ≥ 1 by exact Nat.one_le_cast.2 n.2 ]

/-
If g satisfies the condition with r > 0, then g is strictly increasing.
-/
lemma strict_mono_of_exists_function {r : ℝ} {g : PNat → PNat} (hr : r > 0)
    (h : ∀ n : PNat, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    StrictMono g := by
      intros a b hab; induction' b using PNat.recOn with n IH <;> aesop;
      rcases eq_or_lt_of_le ( show a ≤ n from Nat.le_of_lt_succ hab ) with rfl | ha <;> [ tauto; exact lt_trans ( IH ha ) <| show g n < g ( n + 1 ) from by { have := h n; exact_mod_cast ( by linarith [ show ( g ( g n ) :ℝ ) ^ r > 0 by positivity ] : ( g n :ℝ ) < g ( n + 1 ) ) } ];
      exact_mod_cast lt_of_sub_pos ( lt_of_lt_of_le ( by positivity ) ( h a ) )

/-
If g satisfies the condition with r > 0, then g(n) >= n for all n.
-/
lemma g_ge_n_of_exists_function {r : ℝ} {g : PNat → PNat} (hr : r > 0)
    (h : ∀ n : PNat, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    ∀ n, g n ≥ n := by
      intro n;
      induction n using PNat.recOn <;> aesop;
      exact Nat.succ_le_of_lt ( lt_of_le_of_lt a ( show g n < g ( n + 1 ) from by exact_mod_cast ( by have := h n; linarith [ show ( 0 :ℝ ) < ( g ( g n ) :ℝ ) ^ r by positivity ] : ( g n :ℝ ) < g ( n + 1 ) ) ) )

/-
Definition: g(n) is eventually greater than or equal to n^k.
-/
def EventuallyGe (g : PNat → PNat) (k : ℝ) := ∃ N : PNat, ∀ n : PNat, n ≥ N → (g n : ℝ) ≥ (n : ℝ) ^ k

/-
For p >= 0 and epsilon > 0, the sum of i^p for i < n is eventually at least n^(p + 1 - epsilon).
-/
lemma sum_pow_lower_bound (p : ℝ) (hp : p ≥ 0) (ε : ℝ) (hε : ε > 0) :
    ∃ N : ℕ, ∀ n ≥ N, ∑ i ∈ Finset.range n, (i : ℝ) ^ p ≥ (n : ℝ) ^ (p + 1 - ε) := by
      have h_sum_lower_bound : Filter.Tendsto (fun n : ℕ => (∑ i ∈ Finset.range n, (i : ℝ) ^ p) / (n : ℝ) ^ (p + 1 - ε)) Filter.atTop Filter.atTop := by
        -- We can bound the sum $\sum_{i=0}^{n-1} i^p$ from below by $\int_{0}^{n} x^p \, dx$.
        have h_integral_bound : ∀ n : ℕ, (∑ i ∈ Finset.range n, (i : ℝ) ^ p) ≥ (∫ x in (0 : ℝ)..n, x ^ p) - (n : ℝ) ^ p := by
          bound;
          induction n <;> aesop;
          · positivity;
          · -- We can bound the integral $\int_{n}^{n+1} x^p \, dx$ from above by $(n+1)^p$.
            have h_integral_bound : ∫ x in (n : ℝ)..((n + 1) : ℝ), x ^ p ≤ (n + 1 : ℝ) ^ p := by
              refine' le_trans ( intervalIntegral.integral_mono_on _ _ _ _ ) _;
              exacts [ fun x => ( n + 1 ) ^ p, by norm_num, by exact intervalIntegral.intervalIntegrable_rpow' ( by linarith ), by exact Continuous.intervalIntegrable ( by continuity ) _ _, fun x hx => Real.rpow_le_rpow ( by linarith [ hx.1 ] ) ( by linarith [ hx.2 ] ) ( by linarith ), by norm_num ];
            rw [ Finset.sum_range_succ, ← intervalIntegral.integral_add_adjacent_intervals ];
            exacts [ add_le_add a h_integral_bound, intervalIntegral.intervalIntegrable_rpow' ( by linarith ), intervalIntegral.intervalIntegrable_rpow' ( by linarith ) ];
        -- We can simplify the expression inside the limit.
        suffices h_simplify : Filter.Tendsto (fun n : ℕ => ((n : ℝ) ^ (p + 1) / (p + 1) - (n : ℝ) ^ p) / (n : ℝ) ^ (p + 1 - ε)) Filter.atTop Filter.atTop by
          refine' Filter.tendsto_atTop_mono _ h_simplify;
          intro n; gcongr ; aesop;
          convert h_integral_bound n using 1;
          rw [ integral_rpow ] <;> norm_num;
          · rw [ Real.zero_rpow ( by linarith ), sub_zero ];
          · linarith;
        -- Simplify the expression inside the limit.
        suffices h_simplify : Filter.Tendsto (fun n : ℕ => (n : ℝ) ^ ε / (p + 1) - (n : ℝ) ^ (ε - 1)) Filter.atTop Filter.atTop by
          refine h_simplify.congr' ?_;
          filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn;
          rw [ eq_div_iff ( by positivity ) ] ; ring;
          norm_num [ mul_assoc, mul_left_comm, ← Real.rpow_add ( Nat.cast_pos.mpr hn ) ] ; ring;
          rw [ mul_right_comm, ← Real.rpow_add ( by positivity ) ] ; ring;
        -- We can factor out $n^\epsilon$ from the expression.
        suffices h_factor : Filter.Tendsto (fun n : ℕ => (n : ℝ) ^ ε * (1 / (p + 1) - 1 / (n : ℝ))) Filter.atTop Filter.atTop by
          refine h_factor.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn; rw [ Real.rpow_sub ( by positivity ), Real.rpow_one ] ; ring );
        -- We can use the fact that $n^\epsilon$ grows faster than $1 / n$.
        have h_lim : Filter.Tendsto (fun n : ℕ => (n : ℝ) ^ ε) Filter.atTop Filter.atTop := by
          exact tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop;
        apply Filter.Tendsto.atTop_mul_pos;
        exacts [ show 0 < 1 / ( p + 1 ) by positivity, h_lim, le_trans ( tendsto_const_nhds.sub ( tendsto_one_div_atTop_nhds_zero_nat ) ) ( by norm_num ) ];
      exact Filter.eventually_atTop.mp ( h_sum_lower_bound.eventually_ge_atTop 1 ) |> fun ⟨ N, hN ⟩ => ⟨ N + 1, fun n hn => by have := hN n ( by linarith ) ; rw [ ge_iff_le ] at *; rw [ le_div_iff₀ ( by exact Real.rpow_pos_of_pos ( Nat.cast_pos.mpr <| by linarith ) _ ) ] at *; linarith ⟩

/-
If g satisfies the condition and is eventually greater than n^k, then it is eventually greater than n^(r*k^2 + 1 - epsilon).
-/
lemma boost_exponent {r : ℝ} {g : PNat → PNat} (hr : r > 0)
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r)
    (h_ge_n : ∀ n, g n ≥ n)
    (k : ℝ) (hk : EventuallyGe g k) (hk_pos : k > 0) :
    ∀ ε > 0, EventuallyGe g (r * k^2 + 1 - ε) := by
      intro ε hε_pos
      obtain ⟨N, hN⟩ : ∃ N : ℕ+, ∀ n ≥ N, (g n : ℝ) ≥ (n : ℝ) ^ k := hk;
      -- Using the result from `sum_pow_lower_bound`, we have `∑ i ∈ Finset.range (n - N), (i + N : ℝ) ^ (r * k ^ 2) ≥ (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)` for sufficiently large `n`.
      obtain ⟨M, hM⟩ : ∃ M : ℕ+, ∀ n ≥ M, ∑ i ∈ Finset.range (n - N), (i + N : ℝ) ^ (r * k ^ 2) ≥ (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2) := by
        -- Using the result from `sum_pow_lower_bound`, we have `∑ i ∈ Finset.range (n - N), (i + N : ℝ) ^ (r * k ^ 2) ≥ (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)` for sufficiently large `n`. Let's choose such an `M`.
        have h_sum_pow_lower_bound : ∃ M : ℕ, ∀ n ≥ M, ∑ i ∈ Finset.range n, (i + N : ℝ) ^ (r * k ^ 2) ≥ (n : ℝ) ^ (r * k ^ 2 + 1 - ε / 2) := by
          have := sum_pow_lower_bound ( r * k ^ 2 ) ( by positivity ) ( ε / 2 ) ( half_pos hε_pos );
          obtain ⟨ M, hM ⟩ := this; use M; intros n hn; specialize hM n hn; refine' le_trans hM _ ; gcongr ; aesop;
        cases' h_sum_pow_lower_bound with M hM; use ⟨ M + N, by positivity ⟩ ; aesop;
        convert hM ( n - N ) ( Nat.le_sub_of_add_le ( by linarith [ show ( n : ℕ ) ≥ M + N from a ] ) ) using 1 ; rw [ Nat.cast_sub ( show ( N : ℕ ) ≤ n from by linarith [ show ( n : ℕ ) ≥ M + N from a ] ) ];
      -- Using the result from `sum_pow_lower_bound`, we have `∑ i ∈ Finset.range (n - N), (i + N : ℝ) ^ (r * k ^ 2) ≥ (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)` for sufficiently large `n`. Therefore, `g(n) ≥ g(N) + (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)`.
      have h_g_lower_bound : ∀ n ≥ max M N, (g n : ℝ) ≥ (g N : ℝ) + (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2) := by
        intros n hn
        have h_g_lower_bound_step : ∀ m ≥ N, (g (m + 1) : ℝ) - (g m : ℝ) ≥ (m : ℝ) ^ (r * k ^ 2) := by
          intros m hm
          have h_g_g_m : (g (g m) : ℝ) ≥ (m : ℝ) ^ (k ^ 2) := by
            have := hN ( g m ) ( le_trans hm ( h_ge_n m ) );
            refine le_trans ?_ this;
            rw [ sq, Real.rpow_mul ] <;> norm_cast ; aesop;
            · exact Real.rpow_le_rpow ( by positivity ) ( hN m hm ) ( by positivity );
            · positivity;
          refine le_trans ?_ ( h_cond m );
          exact le_trans ( by rw [ ← Real.rpow_mul ( by positivity ) ] ; ring_nf; norm_num ) ( Real.rpow_le_rpow ( by positivity ) h_g_g_m ( by positivity ) );
        -- Applying the result from `h_g_lower_bound_step` repeatedly, we get:
        have h_g_lower_bound_sum : ∀ m ≥ N, (g m : ℝ) ≥ (g N : ℝ) + ∑ i ∈ Finset.Ico (N : ℕ) m, (i : ℝ) ^ (r * k ^ 2) := by
          intro m hm; induction' m using PNat.recOn with m IH <;> aesop;
          cases hm.eq_or_lt <;> [ aesop; erw [ Finset.sum_Ico_succ_top ] ];
          · linarith [ IH ( Nat.le_of_lt_succ ‹_› ), h_g_lower_bound_step m ( Nat.le_of_lt_succ ‹_› ) ];
          · exact Nat.le_of_lt_succ ‹_›;
        refine le_trans ( add_le_add_left ( hM n ( le_trans ( le_max_left _ _ ) hn ) ) _ ) ?_;
        convert h_g_lower_bound_sum n ( le_trans ( le_max_right _ _ ) hn ) |> le_trans _ using 1;
        norm_num [ add_comm, Finset.sum_Ico_eq_sum_range ];
      -- Since $(n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)$ grows faster than $(n : ℝ) ^ (r * k ^ 2 + 1 - ε)$, we can conclude that $g(n) \geq (n : ℝ) ^ (r * k ^ 2 + 1 - ε)$ for sufficiently large $n$.
      have h_eventually_ge : ∃ M' : ℕ+, ∀ n ≥ M', (n - N : ℝ) ^ (r * k ^ 2 + 1 - ε / 2) ≥ (n : ℝ) ^ (r * k ^ 2 + 1 - ε) := by
        -- We can divide both sides by $(n : ℝ) ^ (r * k ^ 2 + 1 - ε / 2)$ to get $(1 - N / n) ^ (r * k ^ 2 + 1 - ε / 2) ≥ (n : ℝ) ^ (-ε / 2)$.
        suffices h_div : ∃ M' : ℕ+, ∀ n ≥ M', (1 - N / (n : ℝ)) ^ (r * k ^ 2 + 1 - ε / 2) ≥ (n : ℝ) ^ (-ε / 2) by
          obtain ⟨ M', hM' ⟩ := h_div; use Max.max M' N; intro n hn; specialize hM' n ( le_trans ( le_max_left _ _ ) hn ) ; rw [ one_sub_div ( by positivity ) ] at hM'; aesop;
          rw [ Real.div_rpow ( sub_nonneg.mpr <| mod_cast right ) ( by positivity ) ] at hM';
          rw [ le_div_iff₀ ( by positivity ) ] at hM';
          convert hM' using 1 ; rw [ ← Real.rpow_add ( by positivity ) ] ; ring;
        -- As $n \to \infty$, $(1 - N / n) ^ (r * k ^ 2 + 1 - ε / 2) \to 1$ and $(n : ℝ) ^ (-ε / 2) \to 0$.
        have h_lim : Filter.Tendsto (fun n : ℕ+ => (1 - N / (n : ℝ)) ^ (r * k ^ 2 + 1 - ε / 2)) Filter.atTop (nhds 1) ∧ Filter.Tendsto (fun n : ℕ+ => (n : ℝ) ^ (-ε / 2)) Filter.atTop (nhds 0) := by
          constructor;
          · exact le_trans ( Filter.Tendsto.rpow ( tendsto_const_nhds.sub <| tendsto_const_nhds.div_atTop <| tendsto_natCast_atTop_atTop.comp <| Filter.tendsto_atTop_atTop.mpr fun x => ⟨ ⟨ x + 1, Nat.succ_pos x ⟩, fun n hn => Nat.le_of_succ_le hn ⟩ ) tendsto_const_nhds <| Or.inl <| by nlinarith [ show 0 < r * k ^ 2 by positivity ] ) <| by norm_num;
          · simpa [ neg_div ] using tendsto_rpow_neg_atTop ( by linarith : 0 < ε / 2 ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop.comp <| Filter.tendsto_atTop_atTop.mpr fun x => ⟨ ⟨ x + 1, Nat.succ_pos x ⟩, fun n hn => Nat.le_of_succ_le hn ⟩;
        have := h_lim.1.sub h_lim.2;
        exact Filter.eventually_atTop.mp ( this.eventually ( lt_mem_nhds ( show 1 - 0 > 0 by norm_num ) ) ) |> fun ⟨ M', hM' ⟩ ↦ ⟨ M', fun n hn ↦ by linarith [ hM' n hn ] ⟩;
      obtain ⟨ M', hM' ⟩ := h_eventually_ge; use Max.max M' ( Max.max M N ) ; aesop;
      exact le_trans ( hM' n left ) ( le_trans ( le_add_of_nonneg_left <| Nat.cast_nonneg _ ) ( h_g_lower_bound n left_1 right ) )

/-
If r > 1/4, then g grows faster than any polynomial n^K.
-/
lemma eventually_ge_any_k {r : ℝ} (hr : r > 1 / 4) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    ∀ K, EventuallyGe g K := by
      -- We construct a sequence $k_m$ such that $k_m \to \infty$.
      have h_seq : ∃ k_seq : ℕ → ℝ, (∀ m, k_seq m > 0) ∧ (∀ m, EventuallyGe g (k_seq m)) ∧ (∀ m, k_seq (m + 1) ≥ r * k_seq m^2 + 1 - (1 / 2) * (r * k_seq m^2 + 1 - k_seq m)) ∧ (StrictMono k_seq) := by
        refine' ⟨ fun m => Nat.recOn m 1 fun m ih => r * ih^2 + 1 - ( 1 / 2 ) * ( r * ih^2 + 1 - ih ), _, _, _, strictMono_nat_of_lt_succ _ ⟩ <;> norm_num;
        · intro m; induction m <;> norm_num ; nlinarith;
        · intro m;
          induction m <;> aesop;
          · use 1;
            aesop;
            exact PNat.recOn n ( by norm_num ) fun n ihn => Nat.succ_le_of_lt ( lt_of_le_of_lt ihn ( show g n < g ( n + 1 ) from by have := h_cond n; exact_mod_cast ( by nlinarith [ show ( g ( g n ) : ℝ ) ^ r > 0 by positivity ] : ( g n : ℝ ) < g ( n + 1 ) ) ) );
          · have := boost_exponent ( show 0 < r by positivity ) h_cond ( g_ge_n_of_exists_function ( show 0 < r by positivity ) h_cond ) _ a;
            convert this _ _ _ using 1;
            · exact Nat.recOn n ( by norm_num ) fun m ih => by norm_num; nlinarith [ sq_nonneg ( r * ( Nat.rec 1 ( fun m ih => r * ih ^ 2 + 1 - 2⁻¹ * ( r * ih ^ 2 + 1 - ih ) ) m : ℝ ) - 1 ), mul_inv_cancel₀ ( by norm_num : ( 2 : ℝ ) ≠ 0 ) ] ;
            · field_simp;
              nlinarith [ sq_nonneg ( r * ( Nat.rec 1 ( fun m ih => ( 2 * ( r * ih ^ 2 + 1 ) - ( r * ih ^ 2 + 1 - ih ) ) / 2 ) n : ℝ ) - 1 / 2 ) ];
        · intro n;
          nlinarith [ sq_nonneg ( r * ( Nat.rec 1 ( fun m ih => r * ih ^ 2 + 1 - 1 / 2 * ( r * ih ^ 2 + 1 - ih ) ) n : ℝ ) - 1 / 2 ) ];
      -- Since $k_m \to \infty$, for any $K$, eventually $k_m > K$.
      obtain ⟨k_seq, hk_seq⟩ := h_seq
      have hk_seq_inf : Filter.Tendsto k_seq Filter.atTop Filter.atTop := by
        -- By contradiction, assume $k_m$ is bounded above.
        by_contra h_bounded;
        -- Since $k_m$ is strictly increasing and bounded above, it must converge to some limit $L$.
        obtain ⟨L, hL⟩ : ∃ L, Filter.Tendsto k_seq Filter.atTop (nhds L) := by
          rw [ Filter.tendsto_atTop_atTop ] at h_bounded ; aesop;
          exact ⟨ _, tendsto_atTop_isLUB right.monotone ( isLUB_ciSup ⟨ w, Set.forall_mem_range.2 fun m => by obtain ⟨ n, hn₁, hn₂ ⟩ := h m; linarith [ right.monotone hn₁ ] ⟩ ) ⟩;
        -- Taking the limit of both sides of the inequality $k_{m+1} \geq r k_m^2 + 1 - \epsilon_m$, we get $L \geq r L^2 + 1$.
        have h_lim_ineq : L ≥ r * L^2 + 1 := by
          have h_lim_ineq : Filter.Tendsto (fun m => r * k_seq m^2 + 1 - (1 / 2) * (r * k_seq m^2 + 1 - k_seq m)) Filter.atTop (nhds (r * L^2 + 1 - (1 / 2) * (r * L^2 + 1 - L))) := by
            exact Filter.Tendsto.sub ( Filter.Tendsto.add ( tendsto_const_nhds.mul ( hL.pow 2 ) ) tendsto_const_nhds ) ( Filter.Tendsto.mul tendsto_const_nhds ( Filter.Tendsto.sub ( Filter.Tendsto.add ( tendsto_const_nhds.mul ( hL.pow 2 ) ) tendsto_const_nhds ) hL ) );
          have h_lim_ineq : Filter.Tendsto (fun m => k_seq (m + 1)) Filter.atTop (nhds L) := by
            exact hL.comp ( Filter.tendsto_add_atTop_nat 1 );
          linarith [ le_of_tendsto_of_tendsto ‹Filter.Tendsto ( fun m => r * k_seq m ^ 2 + 1 - 1 / 2 * ( r * k_seq m ^ 2 + 1 - k_seq m ) ) Filter.atTop ( nhds ( r * L ^ 2 + 1 - 1 / 2 * ( r * L ^ 2 + 1 - L ) ) ) › h_lim_ineq ( Filter.eventually_atTop.mpr ⟨ 0, fun m hm => hk_seq.2.2.1 m ⟩ ) ];
        nlinarith [ sq_nonneg ( L * r - 1 / 2 ) ];
      intros K
      obtain ⟨m, hm⟩ : ∃ m, k_seq m > K := by
        exact ( hk_seq_inf.eventually_gt_atTop K ) |> fun h => h.exists;
      obtain ⟨ N, hN ⟩ := hk_seq.2.1 m;
      exact ⟨ N, fun n hn => le_trans ( Real.rpow_le_rpow_of_exponent_le ( mod_cast PNat.one_le _ ) hm.le ) ( hN n hn ) ⟩

/-
Definition of the sequence k_n = log(g(n+2)) / log(n+2). We use n+2 to ensure the denominator is non-zero.
-/
noncomputable def k_seq (g : PNat → PNat) (n : ℕ) : ℝ :=
  Real.log (g ⟨n + 2, Nat.succ_pos (n + 1)⟩) / Real.log (n + 2)

/-
The sequence k_n tends to infinity.
-/
lemma k_seq_tendsto_atTop {r : ℝ} (hr : r > 1 / 4) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    Filter.Tendsto (k_seq g) Filter.atTop Filter.atTop := by
      -- For any $M$, choose $K = M$.
      have h_forall_M : ∀ M : ℝ, ∃ N : ℕ+, ∀ n ≥ N, (Real.log (g n) / Real.log n) ≥ M := by
        -- Let's choose any $M$.
        intro M
        -- From `eventually_ge_any_k K`, there exists $N$ such that for $n \ge N$, $g(n) \ge n^K$.
        obtain ⟨N, hN⟩ : ∃ N : ℕ+, ∀ n ≥ N, (g n : ℝ) ≥ (n : ℝ) ^ M := by
          have := eventually_ge_any_k ( show r > 1 / 4 by linarith ) h_cond M;
          aesop;
        refine' ⟨ N + 1, fun n hn => _ ⟩ ; rw [ ge_iff_le ] ; rw [ le_div_iff₀ <| Real.log_pos <| mod_cast lt_of_le_of_lt ( PNat.one_le _ ) hn ] ; aesop;
        simpa only [ Real.log_rpow ( Nat.cast_pos.mpr n.pos ) ] using Real.log_le_log ( by positivity ) ( hN n ( Nat.le_of_succ_le hn ) );
      refine' Filter.tendsto_atTop_atTop.mpr _;
      intro b; rcases h_forall_M b with ⟨ N, hN ⟩ ; use N; intro a ha; specialize hN ⟨ a + 2, Nat.succ_pos _ ⟩ ( Nat.le_trans ha ( Nat.le_add_right _ _ ) ) ; aesop;

/-
Definition of the tail infimum of a sequence f at index n.
-/
noncomputable def tail_inf (f : ℕ → ℝ) (n : ℕ) : ℝ := sInf {x | ∃ m ≥ n, f m = x}

/-
tail_inf is monotone for sequences tending to infinity.
-/
lemma tail_inf_mono (f : ℕ → ℝ) : Monotone (tail_inf f) := by
  refine' monotone_nat_of_le_succ _;
  intros n
  unfold tail_inf;
  by_cases h : BddBelow { x | ∃ m ≥ n, f m = x } <;> aesop;
  · refine' le_csInf _ _;
    · exact ⟨ _, ⟨ n + 1, le_rfl, rfl ⟩ ⟩;
    · rintro _ ⟨ m, hm₁, rfl ⟩ ; exact csInf_le h ⟨ m, by linarith, rfl ⟩;
  · rw [ Real.sInf_of_not_bddBelow ];
    contrapose! h;
    exact ⟨ Min.min h.choose ( f n ), by rintro x ⟨ m, hm₁, rfl ⟩ ; exact if hm₂ : m = n then by aesop else le_trans ( min_le_left _ _ ) ( h.choose_spec ⟨ m, by omega, rfl ⟩ ) ⟩

/-
If f tends to infinity, then tail_inf f tends to infinity.
-/
lemma tail_inf_to_atTop {f : ℕ → ℝ} (hf : Filter.Tendsto f Filter.atTop Filter.atTop) :
    Filter.Tendsto (tail_inf f) Filter.atTop Filter.atTop := by
      refine' Filter.tendsto_atTop_atTop.mpr fun M => _;
      have := hf.eventually_ge_atTop M;
      aesop;
      exact ⟨ w, fun n hn => le_csInf ⟨ f n, ⟨ n, le_rfl, rfl ⟩ ⟩ fun x hx => by rcases hx with ⟨ m, hm, rfl ⟩ ; exact h m ( hn.trans hm ) ⟩

/-
Inequality relating terms of k_seq.
-/
lemma k_seq_ineq {r : ℝ} (hr : r > 0) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r)
    (h_ge_n : ∀ n, g n ≥ n) :
    ∃ N : ℕ, ∀ n : PNat, (n : ℕ) ≥ N →
    k_seq g ((n : ℕ) - 1) * (Real.log ((n : ℕ) + 1) / Real.log (n : ℕ)) ≥
    r * k_seq g ((g n : ℕ) - 2) * k_seq g ((n : ℕ) - 2) := by
      -- Substitute the definitions of `k_seq` into the inequality.
      have h_subst : ∀ n : ℕ+, (n : ℕ) ≥ 2 →
          (Real.log (g ⟨n + 1, Nat.succ_pos n⟩) / Real.log (n + 1)) * (Real.log (n + 1) / Real.log n) ≥
          r * (Real.log (g ⟨g n, Nat.pos_of_ne_zero (by
          positivity)⟩) / Real.log (g n)) * (Real.log (g ⟨n, Nat.pos_of_ne_zero (by
          positivity)⟩) / Real.log n) := by
            intro n hn; have := h_cond n; rw [ div_mul_div_cancel₀ ] <;> norm_cast at * ; aesop;
            · -- Applying the inequality $\log(g(n+1)) \geq r \log(g(g(n)))$ from `h_cond`.
              have h_log_ineq : Real.log (g (n + 1)) ≥ r * Real.log (g (g n)) := by
                exact le_trans ( by rw [ ← Real.log_rpow ( by positivity ) ] ) ( Real.log_le_log ( by positivity ) ( le_trans ( h_cond n ) ( sub_le_self _ ( by positivity ) ) ) );
              convert mul_le_mul_of_nonneg_right h_log_ineq <| inv_nonneg.mpr <| Real.log_nonneg <| Nat.one_le_cast.mpr <| PNat.pos n using 1 ; ring;
              linarith! [ inv_mul_cancel_left₀ ( show Real.log ( g n : ℝ ) ≠ 0 from ne_of_gt <| Real.log_pos <| mod_cast lt_of_lt_of_le ( show 1 < ( n : ℕ ) from hn ) <| h_ge_n n ) <| r * Real.log ( g ( g n ) : ℝ ) * ( Real.log ( n : ℝ ) ) ⁻¹ ];
            · exact ne_of_gt <| Real.log_pos <| mod_cast Nat.succ_lt_succ n.pos
      generalize_proofs at *;
      unfold k_seq;
      refine' ⟨ 2, fun n hn => _ ⟩ ; specialize h_subst n hn ; rcases n with ( _ | _ | n ) <;> norm_num at * ;
      rcases k : g ⟨ n + 1 + 1, Nat.succ_pos _ ⟩ with ( _ | _ | k ) <;> aesop;
      · contradiction;
      · exact_mod_cast h_subst;
      · exact_mod_cast h_subst

/-
L_seq tends to infinity.
-/
noncomputable def L_seq (g : PNat → PNat) (n : ℕ) : ℝ := tail_inf (k_seq g) n

lemma L_seq_tendsto_atTop {r : ℝ} (hr : r > 1 / 4) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    Filter.Tendsto (L_seq g) Filter.atTop Filter.atTop := by
      apply_rules [ tail_inf_to_atTop, k_seq_tendsto_atTop ]

/-
g(n) is eventually at least n^2.
-/
lemma g_ge_n_sq {r : ℝ} (hr : r > 1 / 4) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    ∃ N : ℕ, ∀ n : PNat, (n : ℕ) ≥ N → (g n : ℝ) ≥ (n : ℝ) ^ 2 := by
      -- Since $L_n \to \infty$, there exists $N$ such that for $n \ge N$, $k_n \ge 2$.
      obtain ⟨N₁, hN₁⟩ : ∃ N₁ : ℕ, ∀ n ≥ N₁, k_seq g n ≥ 2 := by
        have h_L_seq_tendsto_infty : Filter.Tendsto (k_seq g) Filter.atTop Filter.atTop := by
          exact k_seq_tendsto_atTop hr h_cond;
        simpa using h_L_seq_tendsto_infty.eventually_ge_atTop 2;
      refine' ⟨ N₁ + 2, fun n hn => _ ⟩ ; specialize hN₁ ( n - 2 ) ; rcases n with ( _ | _ | n ) <;> norm_num at *;
      · linarith;
      · specialize hN₁ ( by omega ) ; unfold k_seq at hN₁ ; aesop;
        rw [ le_div_iff₀ ( Real.log_pos <| by linarith ) ] at hN₁ ; rw [ ← Real.log_le_log_iff ( by positivity ) ( by positivity ), Real.log_pow ] ; ring_nf at * ; aesop

/-
Eventually, k_{g(n)-2} <= 1/2 * k_{n-1}.
-/
lemma eventually_halving {r : ℝ} (hr : r > 1 / 4) {g : PNat → PNat}
    (h_cond : ∀ n, (g (n + 1) : ℝ) - g n ≥ (g (g n) : ℝ) ^ r) :
    ∃ N : ℕ, ∀ n : PNat, (n : ℕ) ≥ N → k_seq g ((g n : ℕ) - 2) ≤ (1 / 2) * k_seq g ((n : ℕ) - 1) := by
      -- From `k_seq_ineq`, $k_{n-1} \frac{\log(n+1)}{\log n} \ge r k_{g(n)-2} k_{n-2}$.
      -- So $k_{g(n)-2} \le \frac{k_{n-1}}{r k_{n-2}} \frac{\log(n+1)}{\log n}$.
      have h_bound : ∃ N : ℕ, ∀ n : ℕ+, (n : ℕ) ≥ N → k_seq g ((g n : ℕ) - 2) ≤ (k_seq g ((n : ℕ) - 1)) / (r * k_seq g ((n : ℕ) - 2)) * (Real.log ((n : ℕ) + 1) / Real.log (n : ℕ)) := by
        -- Apply `k_seq_ineq` to obtain the inequality.
        obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n : ℕ+, (n : ℕ) ≥ N → k_seq g ((n : ℕ) - 1) * (Real.log ((n : ℕ) + 1) / Real.log (n : ℕ)) ≥ r * k_seq g ((g n : ℕ) - 2) * k_seq g ((n : ℕ) - 2) := by
          -- By Lemma `k_seq_ineq`, we know that there exists such an $N$.
          apply k_seq_ineq (by linarith) h_cond (g_ge_n_of_exists_function (by linarith) h_cond);
        -- Since $k_n \to \infty$, $k_{n-2} \to \infty$.
        have h_k_seq_inf : Filter.Tendsto (k_seq g) Filter.atTop Filter.atTop := by
          exact k_seq_tendsto_atTop hr h_cond;
        have := h_k_seq_inf.eventually_gt_atTop 0; aesop;
        exact ⟨ N + w + 2, fun n hn => by rw [ div_mul_eq_mul_div, le_div_iff₀ ] <;> nlinarith [ hN n ( by linarith ), h ( n - 2 ) ( Nat.le_sub_of_add_le ( by linarith ) ), h ( g n - 2 ) ( Nat.le_sub_of_add_le ( by linarith [ show ( g n : ℕ ) ≥ n from mod_cast g_ge_n_of_exists_function ( by positivity ) h_cond n ] ) ), show 0 < r * k_seq g ( n - 2 ) from mul_pos ( by positivity ) ( h ( n - 2 ) ( Nat.le_sub_of_add_le ( by linarith ) ) ) ] ⟩;
      -- Since $k_n \to \infty$, $k_{n-2} \to \infty$. So $\frac{1}{r k_{n-2}} \to 0$.
      have h_inv_k_n_minus_2 : Filter.Tendsto (fun n : ℕ => 1 / (r * k_seq g ((n : ℕ) - 2))) Filter.atTop (nhds 0) := by
        have h_inv_k_n_minus_2 : Filter.Tendsto (fun n : ℕ => k_seq g n) Filter.atTop Filter.atTop := by
          exact k_seq_tendsto_atTop hr h_cond;
        exact tendsto_const_nhds.div_atTop ( Filter.Tendsto.const_mul_atTop ( by positivity ) ( h_inv_k_n_minus_2.comp ( Filter.tendsto_sub_atTop_nat 2 ) ) );
      -- Also $\frac{\log(n+1)}{\log n} \to 1$.
      have h_log_ratio : Filter.Tendsto (fun n : ℕ => Real.log ((n : ℕ) + 1) / Real.log (n : ℕ)) Filter.atTop (nhds 1) := by
        -- We can use the fact that $\log(n+1) = \log n + \log\left(1 + \frac{1}{n}\right)$.
        suffices h_log_split : Filter.Tendsto (fun n : ℕ => (Real.log n + Real.log (1 + 1 / (n : ℝ))) / Real.log n) Filter.atTop (nhds 1) by
          refine h_log_split.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using by rw [ ← Real.log_mul ( by positivity ) ( by positivity ), mul_add, mul_one_div_cancel ( by positivity ), mul_one ] );
        ring_nf;
        exact le_trans ( Filter.Tendsto.add ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx; rw [ mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( mod_cast hx ) ) ) ] ) ) ( Filter.Tendsto.mul ( Filter.Tendsto.log ( tendsto_const_nhds.add ( tendsto_inverse_atTop_nhds_zero_nat ) ) ( by norm_num ) ) ( tendsto_inv_atTop_zero.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop ) ) ) ) ( by norm_num );
      -- Therefore, eventually the coefficient of $k_{n-1}$ is $\le 1/2$.
      obtain ⟨N₁, hN₁⟩ : ∃ N₁ : ℕ, ∀ n : ℕ, n ≥ N₁ → (1 / (r * k_seq g ((n : ℕ) - 2))) * (Real.log ((n : ℕ) + 1) / Real.log (n : ℕ)) ≤ 1 / 2 := by
        have := h_inv_k_n_minus_2.mul h_log_ratio;
        simpa using this.eventually ( ge_mem_nhds <| by norm_num );
      obtain ⟨ N₂, hN₂ ⟩ := h_bound; use Max.max N₁ N₂; aesop;
      refine le_trans ( hN₂ n right ) ?_;
      convert mul_le_mul_of_nonneg_right ( hN₁ n left ) ( show 0 ≤ k_seq g ( ( n : ℕ ) - 1 ) from div_nonneg ( Real.log_nonneg <| mod_cast PNat.one_le _ ) <| Real.log_nonneg <| mod_cast Nat.le_add_left _ _ ) using 1 ; ring

/-
The ratio log(n+1)/log(n) tends to 1.
-/
lemma log_ratio_tendsto_one : Filter.Tendsto (fun n : ℕ => Real.log ((n : ℝ) + 1) / Real.log (n : ℝ)) Filter.atTop (nhds 1) := by
  -- Rewrite the limit expression using the property of logarithms: $\log(n+1) = \log(n) + \log\left(1 + \frac{1}{n}\right)$.
  suffices h_log : Filter.Tendsto (fun n : ℕ => (Real.log n + Real.log (1 + 1 / (n : ℝ))) / Real.log n) Filter.atTop (nhds 1) by
    refine h_log.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using by rw [ ← Real.log_mul ( by positivity ) ( by positivity ), mul_add, mul_one_div_cancel ( by positivity ), mul_one ] );
  ring_nf;
  exact le_trans ( Filter.Tendsto.add ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( mod_cast hx ) ) ) ] ) ) ( Filter.Tendsto.mul ( Filter.Tendsto.log ( tendsto_const_nhds.add ( tendsto_inverse_atTop_nhds_zero_nat ) ) ( by norm_num ) ) ( tendsto_inv_atTop_zero.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop ) ) ) ) ( by norm_num )

/-
There is no function g satisfying the condition for r > 1/4.
-/
theorem not_exists_function_gt_one_quarter {r : ℝ} (hr : r > 1 / 4) : ¬ ExistsFunction r := by
  aesop;
  -- We have shown that $L_n \to \infty$, so $L_n > 0$ eventually.
  obtain ⟨N₀, hN₀⟩ : ∃ N₀ : ℕ, ∀ n ≥ N₀, L_seq (a.choose) n > 0 := by
    have := L_seq_tendsto_atTop ( show r > 1 / 4 by norm_num at *; linarith ) a.choose_spec;
    exact Filter.eventually_atTop.mp ( this.eventually_gt_atTop 0 );
  -- We have $k_{g(n)-2} \le (1/2) k_{n-1}$ eventually.
  obtain ⟨N₁, hN₁⟩ : ∃ N₁ : ℕ, ∀ n : PNat, (n : ℕ) ≥ N₁ → k_seq (a.choose) ((a.choose n : ℕ) - 2) ≤ (1 / 2) * k_seq (a.choose) ((n : ℕ) - 1) := by
    apply_rules [ eventually_halving ];
    · aesop;
    · exact a.choose_spec;
  -- Since $g(n) \ge n^2$, $g(n)-2 \ge n-1$ eventually.
  obtain ⟨N₂, hN₂⟩ : ∃ N₂ : ℕ, ∀ n : PNat, (n : ℕ) ≥ N₂ → (a.choose n : ℕ) - 2 ≥ (n : ℕ) - 1 := by
    have := a.choose_spec;
    have := g_ge_n_sq ( by linarith ) this;
    aesop;
    exact ⟨ w + 2, fun n hn => by rw [ tsub_add_eq_add_tsub ( by exact Nat.le_of_lt_succ <| by { rw [ ← @Nat.cast_lt ℝ ] ; push_cast; nlinarith [ h n <| by linarith, show ( n : ℝ ) ≥ w + 2 by exact_mod_cast hn ] } ) ] ; exact Nat.le_sub_of_add_le <| by { rw [ ← @Nat.cast_le ℝ ] ; push_cast; nlinarith [ h n <| by linarith, show ( n : ℝ ) ≥ w + 2 by exact_mod_cast hn ] } ⟩;
  -- Thus $k_{n-1} \ge 2 k_{g(n)-2} \ge 2 L_{g(n)-2}$.
  have h_k_ge_2L : ∀ n : PNat, (n : ℕ) ≥ max (max N₀ N₁) N₂ → k_seq (a.choose) ((n : ℕ) - 1) ≥ 2 * L_seq (a.choose) ((n : ℕ) - 1) := by
    intros n hn
    have h_k_ge_2L_step : k_seq (a.choose) ((a.choose n : ℕ) - 2) ≥ L_seq (a.choose) ((n : ℕ) - 1) := by
      refine' csInf_le _ _ <;> aesop;
      exact ⟨ 0, by rintro x ⟨ m, hm₁, rfl ⟩ ; exact div_nonneg ( Real.log_nonneg <| mod_cast PNat.one_le _ ) ( Real.log_nonneg <| mod_cast Nat.le_add_left _ _ ) ⟩;
    linarith [ hN₁ n ( by aesop ) ];
  -- Thus $L_N = \inf_{m \ge N} k_m \ge 2 L_N$.
  have h_L_ge_2L : ∀ N : ℕ, N ≥ max (max N₀ N₁) N₂ → L_seq (a.choose) N ≥ 2 * L_seq (a.choose) N := by
    intros N hN
    have h_inf_ge_2L : ∀ m ≥ N, k_seq (a.choose) m ≥ 2 * L_seq (a.choose) N := by
      intros m hm
      specialize h_k_ge_2L ⟨m + 1, Nat.succ_pos m⟩ (by
      exact le_trans hN ( Nat.le_succ_of_le hm ));
      exact le_trans ( mul_le_mul_of_nonneg_left ( show L_seq ( Exists.choose a ) N ≤ L_seq ( Exists.choose a ) m from by exact ( tail_inf_mono _ ) <| by linarith ) zero_le_two ) h_k_ge_2L;
    exact le_csInf ⟨ _, ⟨ N, le_rfl, rfl ⟩ ⟩ fun x hx => by rcases hx with ⟨ m, hm₁, rfl ⟩ ; exact h_inf_ge_2L m hm₁;
  linarith [ hN₀ ( Max.max ( Max.max N₀ N₁ ) N₂ ) ( by norm_num ), h_L_ge_2L ( Max.max ( Max.max N₀ N₁ ) N₂ ) ( by norm_num ) ]

/-
The largest constant r is 1/4.
-/
theorem largest_constant : IsGreatest {r : ℝ | ExistsFunction r} (1 / 4) := by
  constructor
  · exact exists_function_one_quarter
  · intro r hr
    by_contra h_gt
    have : r > 1/4 := lt_of_not_ge h_gt
    exact not_exists_function_gt_one_quarter this hr
