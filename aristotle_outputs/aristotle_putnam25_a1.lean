/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1e587c61-0b0d-4370-b57a-7b1d04e8e220
-/

/-
We define the sequence $(m_k, n_k)$ starting from distinct positive integers $m_0, n_0$.
We prove that for sufficiently large $k$, $\gcd(2m_k+1, 2n_k+1) = 1$.
The proof tracks the difference $\Delta_k = |m_k - n_k|$. We show that $\Delta_{k+1} = \frac{2}{d_k} \Delta_k$ where $d_k = \gcd(2m_k+1, 2n_k+1)$.
This implies $\Delta_k = \Delta_0 \frac{2^k}{\prod_{i=0}^{k-1} d_i}$.
Since $d_i$ are odd, the product $\prod_{i=0}^{k-1} d_i$ must divide $\Delta_0$.
Since $\Delta_0$ is constant, the product must eventually stabilize, implying $d_k = 1$ for all sufficiently large $k$.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0
noncomputable section

/-
Let $m_0, n_0$ be distinct positive integers. Define $m_k, n_k$ by $m_k/n_k = (2m_{k-1}+1)/(2n_{k-1}+1)$ with $\gcd(m_k, n_k)=1$. Then $\gcd(2m_k+1, 2n_k+1)=1$ for all sufficiently large $k$.
-/
def next_step (p : ℕ × ℕ) : ℕ × ℕ :=
  let m := p.1
  let n := p.2
  let d := Nat.gcd (2 * m + 1) (2 * n + 1)
  ((2 * m + 1) / d, (2 * n + 1) / d)

def problem_seq (m0 n0 : ℕ) : ℕ → ℕ × ℕ
| 0 => (m0, n0) -- Note: The problem starts indexing m_k, n_k from k=1 based on m0, n0?
                -- "Let m0, n0 be distinct... For every positive integer k, define m_k, n_k..."
                -- This implies m_0, n_0 are base cases.
                -- And m_1, n_1 is defined from m_0, n_0.
                -- My definition matches this.
| k + 1 => next_step (problem_seq m0 n0 k)

theorem problem_statement_nat (m0 n0 : ℕ) (h0 : m0 ≠ n0) (hm0 : m0 > 0) (hn0 : n0 > 0) :
  ∃ K, ∀ k ≥ K, Nat.Coprime (2 * (problem_seq m0 n0 k).1 + 1) (2 * (problem_seq m0 n0 k).2 + 1) := by
  -- Let $\Delta_k = |m_k - n_k|$.
  set Δ : ℕ → ℤ := fun k => (problem_seq m0 n0 k).fst - (problem_seq m0 n0 k).snd;
  -- We have $\Delta_{k+1} = \frac{2}{d_k} \Delta_k$, where $d_k = \gcd(2m_k + 1, 2n_k + 1)$.
  have hΔ_recurrence : ∀ k, Δ (k + 1) * Nat.gcd (2 * (problem_seq m0 n0 k).fst + 1) (2 * (problem_seq m0 n0 k).snd + 1) = 2 * Δ k := by
    aesop;
    -- By definition of $problem_seq$, we have $m_{k+1} = \frac{2m_k + 1}{d_k}$ and $n_{k+1} = \frac{2n_k + 1}{d_k}$.
    have h_seq_def : (problem_seq m0 n0 (k + 1)).fst = (2 * (problem_seq m0 n0 k).fst + 1) / Nat.gcd (2 * (problem_seq m0 n0 k).fst + 1) (2 * (problem_seq m0 n0 k).snd + 1) ∧
                       (problem_seq m0 n0 (k + 1)).snd = (2 * (problem_seq m0 n0 k).snd + 1) / Nat.gcd (2 * (problem_seq m0 n0 k).fst + 1) (2 * (problem_seq m0 n0 k).snd + 1) := by
                         bound;
    aesop;
    linarith [ Nat.div_mul_cancel ( Nat.gcd_dvd_left ( 2 * ( problem_seq m0 n0 k |>.1 ) + 1 ) ( 2 * ( problem_seq m0 n0 k |>.2 ) + 1 ) ), Nat.div_mul_cancel ( Nat.gcd_dvd_right ( 2 * ( problem_seq m0 n0 k |>.1 ) + 1 ) ( 2 * ( problem_seq m0 n0 k |>.2 ) + 1 ) ) ];
  -- Since $\Delta_k$ is an integer, $d_0 d_1 \dots d_{k-1}$ must divide $\Delta_0 2^k$.
  have h_prod_divides : ∀ k, (∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1)) ∣ (Int.natAbs (Δ 0)) := by
    -- By definition of $Δ$, we have $Δ_k = Δ_0 * 2^k / (∏_{i=0}^{k-1} d_i)$.
    have hΔ_formula : ∀ k, Δ k * (∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1)) = Δ 0 * 2 ^ k := by
      intro k; induction k <;> simp_all +decide [ pow_succ, mul_assoc, mul_comm, mul_left_comm, Finset.prod_range_succ ] ;
      grind;
    -- Since $\prod_{i=0}^{k-1} d_i$ divides $\Delta_0 * 2^k$ and $\prod_{i=0}^{k-1} d_i$ is odd, it must divide $\Delta_0$.
    intros k
    have h_divides : (∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1)) ∣ Int.natAbs (Δ 0 * 2 ^ k) := by
      rw [ ← Int.natCast_dvd ];
      exact dvd_of_mul_left_eq _ ( hΔ_formula k );
    rw [ Int.natAbs_mul, Int.natAbs_pow ] at h_divides;
    refine' Nat.Coprime.dvd_of_dvd_mul_right _ h_divides;
    refine' Nat.Coprime.prod_left _ ; aesop;
    exact Nat.Coprime.pow_right _ <| Nat.Coprime.symm <| Nat.prime_two.coprime_iff_not_dvd.mpr <| by erw [ Nat.dvd_gcd_iff ] ; norm_num [ ← even_iff_two_dvd, parity_simps ] ;
  -- Since $\Delta_0$ is finite, there exists some $K$ such that for all $k \geq K$, the product $\prod_{i=0}^{k-1} d_i$ is constant.
  obtain ⟨K, hK⟩ : ∃ K, ∀ k ≥ K, (∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1)) = (∏ i ∈ Finset.range K, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1)) := by
    norm_num +zetaDelta at *;
    -- Since $\Delta_0$ is a fixed number, and $d_i$ are odd, the product of $d_i$ can only increase up to $\Delta_0$. Hence, it must stabilize.
    have h_prod_stabilize : Filter.Tendsto (fun k => (∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1))) Filter.atTop (nhds (sSup {∏ i ∈ Finset.range k, Nat.gcd (2 * (problem_seq m0 n0 i).fst + 1) (2 * (problem_seq m0 n0 i).snd + 1) | k : ℕ})) := by
      apply_rules [ tendsto_atTop_ciSup ];
      · exact monotone_nat_of_le_succ fun k => by rw [ Finset.prod_range_succ ] ; exact le_mul_of_one_le_right ( Nat.zero_le _ ) ( Nat.gcd_pos_of_pos_left _ ( Nat.succ_pos _ ) ) ;
      · exact ⟨ _, Set.forall_mem_range.mpr fun k => Nat.le_of_dvd ( Int.natAbs_pos.mpr <| sub_ne_zero_of_ne <| mod_cast h0 ) <| h_prod_divides k ⟩;
    aesop;
    exact ⟨ w, fun k hk => by rw [ h k hk, h w le_rfl ] ⟩;
  use K + 1;
  intro k hk; have := hK k ( by linarith ) ; have := hK ( k + 1 ) ( by linarith ) ; simp_all +decide [ Finset.prod_range_succ ] ;
  nlinarith [ show 0 < ∏ i ∈ Finset.range K, Nat.gcd ( 2 * ( problem_seq m0 n0 i |>.1 ) + 1 ) ( 2 * ( problem_seq m0 n0 i |>.2 ) + 1 ) from Finset.prod_pos fun i hi => Nat.gcd_pos_of_pos_left _ ( Nat.succ_pos _ ) ]
