/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 362a682f-a537-4743-92a5-53b101e9ac1e
-/

/-
We define the sequence $b_n$ by $b_0 = 0$ and $b_{n+1} = 2b_n^2 + b_n + 1$.
We introduce an auxiliary sequence $c_n = 2b_n$ which satisfies $c_{n+1} = c_n^2 + c_n + 2$.
We define a product $P_m = \prod_{i=0}^{m-1} (2c_i + 1)$ and prove a congruence relation $c_{n+m} \equiv c_m + c_n P_m \pmod{c_n^2}$.
Using this, we prove by induction that $v_2(c_{2^k}) = k+2$ and $v_2(P_{2^k}-1) = k+1$.
Finally, we show that $b_{2^{k+1}} - 2b_{2^k}$ has 2-adic valuation $2k+2$.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Let $b_0 = 0$ and $b_{n+1} = 2b_n^2 + b_n + 1$.
-/
def b : ℕ → ℕ
| 0 => 0
| n + 1 => 2 * (b n)^2 + b n + 1

/-
Define $c_n = 2b_n$ and show it satisfies $c_{n+1} = c_n^2 + c_n + 2$.
-/
def c (n : ℕ) : ℕ := 2 * b n

theorem c_recurrence (n : ℕ) : c (n + 1) = (c n)^2 + c n + 2 := by
  -- By definition of $c$, we know that $c (n + 1) = 2 * b (n + 1)$ and $c n = 2 * b n$.
  have hc_def : ∀ n, c n = 2 * b n := by
    aesop
  simp [hc_def];
  rw [ show b ( n + 1 ) = 2 * b n ^ 2 + b n + 1 from rfl ] ; ring

/-
Define $P_m = \prod_{i=0}^{m-1} (2c_i + 1)$.
-/
def P : ℕ → ℕ
| 0 => 1
| n + 1 => P n * (2 * c n + 1)

/-
Show that $c_{n+m} \equiv c_m + c_n P_m \pmod{c_n^2}$.
-/
theorem c_add_mod (n m : ℕ) : c (n + m) ≡ c m + c n * P m [MOD (c n)^2] := by
  induction' m with m ih generalizing n;
  · -- For the base case $m = 0$, we have $c (n + 0) = c n$ and $c 0 + c n * P 0 = 0 + c n * 1 = c n$.
    simp [P];
    norm_num [ show c 0 = 0 by rfl ];
    rfl;
  · have h_step : c (n + (m + 1)) ≡ (c m + c n * P m) ^ 2 + (c m + c n * P m) + 2 [MOD c n ^ 2] := by
      convert ih n |> Nat.ModEq.pow 2 |> Nat.ModEq.add <| ih n |> Nat.ModEq.add <| Nat.ModEq.refl 2 using 1;
      exact c_recurrence _;
    refine h_step.trans <| Nat.ModEq.symm <| Nat.modEq_of_dvd ?_;
    simp +decide [ c_recurrence, P ];
    exact ⟨ P m ^ 2, by ring ⟩

/-
Prove by induction that $v_2(c_{2^k}) = k+2$ and $v_2(P_{2^k}-1) = k+1$.
-/
theorem combined_val (k : ℕ) (hk : k ≥ 1) :
  (2^(k+2) ∣ c (2^k)) ∧ ¬ (2^(k+3) ∣ c (2^k)) ∧
  (2^(k+1) ∣ P (2^k) - 1) ∧ ¬ (2^(k+2) ∣ P (2^k) - 1) := by
    induction hk <;> simp_all +decide [ pow_succ ];
    rename_i k hk ih;
    -- Let's simplify the goal using the properties of $c$ and $P$.
    have h_c : c (2 ^ k * 2) ≡ c (2 ^ k) * (1 + P (2 ^ k)) [MOD (c (2 ^ k))^2] := by
      have := c_add_mod ( 2 ^ k ) ( 2 ^ k ) ; ring_nf at *; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
    have h_P : P (2 ^ k * 2) ≡ P (2 ^ k)^2 [MOD 2 * c (2 ^ k)] := by
      -- Using the recurrence relation for $c$, we can expand $P_{2m}$.
      have h_P_expand : P (2 ^ k * 2) = P (2 ^ k) * ∏ j ∈ Finset.range (2 ^ k), (2 * c (2 ^ k + j) + 1) := by
        have h_P : ∀ m n : ℕ, m ≤ n → P n = P m * ∏ j ∈ Finset.Ico m n, (2 * c j + 1) := by
          intros m n hmn
          induction' hmn with n hn ih;
          · norm_num;
          · rw [ Finset.prod_Ico_succ_top ( by linarith [ Nat.succ_le_succ hn ] ), ← mul_assoc, ← ih, show P ( Nat.succ n ) = P n * ( 2 * c n + 1 ) from rfl ];
        convert h_P ( 2 ^ k ) ( 2 ^ k * 2 ) ( by linarith [ Nat.one_le_pow k 2 zero_lt_two ] ) using 1 ; simp +arith +decide [ Finset.prod_Ico_eq_prod_range ];
        exact Or.inl ( by rw [ two_mul, add_tsub_cancel_left ] );
      -- Using the recurrence relation for $c$, we can simplify each term in the product.
      have h_term_simplify : ∀ j ∈ Finset.range (2 ^ k), 2 * c (2 ^ k + j) + 1 ≡ 2 * c j + 1 [MOD 2 * c (2 ^ k)] := by
        intros j hj
        have h_term_simplify : c (2 ^ k + j) ≡ c j + c (2 ^ k) * P j [MOD (c (2 ^ k))^2] := by
          convert c_add_mod ( 2 ^ k ) j using 1;
        rw [ Nat.modEq_iff_dvd ] at *;
        obtain ⟨ a, ha ⟩ := h_term_simplify; exact ⟨ a * c ( 2 ^ k ) - P j * 1, by push_cast at *; nlinarith ⟩ ;
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, sq ];
      rw [ Finset.prod_congr rfl fun x hx => by rw [ h_term_simplify x ( Finset.mem_range.mp hx ) ] ];
      norm_cast;
      exact congr_arg _ ( by rw [ show P ( 2 ^ k ) = ∏ i ∈ Finset.range ( 2 ^ k ), ( 2 * c i + 1 ) from by exact Nat.recOn ( 2 ^ k ) ( by rfl ) fun n ih => by rw [ Finset.prod_range_succ, show P ( n + 1 ) = P n * ( 2 * c n + 1 ) from rfl ] ; aesop ] );
    -- Let's simplify the goal using the properties of $c$ and $P$ further.
    have h_c_simplified : c (2 ^ k * 2) ≡ c (2 ^ k) * (1 + P (2 ^ k)) [MOD 2 ^ (2 * k + 4)] := by
      refine h_c.of_dvd ?_;
      convert pow_dvd_pow_of_dvd ih.1 2 using 1 ; ring
    have h_P_simplified : P (2 ^ k * 2) ≡ P (2 ^ k)^2 [MOD 2 ^ (k + 3)] := by
      exact h_P.of_dvd <| by obtain ⟨ m, hm ⟩ := ih.1; exact ⟨ m, by rw [ hm ] ; ring ⟩ ;
    -- Let's simplify the goal using the properties of $c$ and $P$ further, considering the divisibility conditions.
    have h_c_div : 2 ^ (k + 3) ∣ c (2 ^ k * 2) ∧ ¬2 ^ (k + 4) ∣ c (2 ^ k * 2) := by
      have h_c_div : 2 ^ (k + 3) ∣ c (2 ^ k) * (1 + P (2 ^ k)) ∧ ¬2 ^ (k + 4) ∣ c (2 ^ k) * (1 + P (2 ^ k)) := by
        obtain ⟨ a, ha ⟩ := ih.1; obtain ⟨ b, hb ⟩ := ih.2.2.1; simp_all +decide [ pow_succ, mul_assoc ] ;
        rw [ Nat.sub_eq_iff_eq_add <| Nat.one_le_iff_ne_zero.mpr <| by aesop_cat ] at hb ; aesop;
        · exact mul_dvd_mul_left _ ( show 8 ∣ 4 * ( a * ( 1 + ( 2 ^ k * ( 2 * b ) + 1 ) ) ) from ⟨ a * ( 1 + ( 2 ^ k * ( 2 * b ) + 1 ) ) / 2, by nlinarith [ Nat.div_mul_cancel ( show 2 ∣ a * ( 1 + ( 2 ^ k * ( 2 * b ) + 1 ) ) from even_iff_two_dvd.mp ( by simp +arith +decide [ mul_add, parity_simps ] ) ) ] ⟩ );
        · rw [ Nat.mul_dvd_mul_iff_left ( by positivity ) ] at *;
          rcases Nat.even_or_odd' a with ⟨ c, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' b with ⟨ d, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] at *;
          rcases k with ( _ | _ | _ | _ | k ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod ] at *;
      have h_c_div : c (2 ^ k * 2) ≡ c (2 ^ k) * (1 + P (2 ^ k)) [MOD 2 ^ (k + 4)] := by
        exact h_c_simplified.of_dvd <| pow_dvd_pow _ <| by linarith;
      rw [ Nat.dvd_iff_mod_eq_zero, Nat.dvd_iff_mod_eq_zero, h_c_div ] ; aesop;
      · exact h_c_div.of_dvd ( pow_dvd_pow _ ( Nat.le_succ _ ) ) ▸ Nat.mod_eq_zero_of_dvd left_1;
      · exact right_1 ( Nat.dvd_of_mod_eq_zero a )
    have h_P_div : 2 ^ (k + 2) ∣ P (2 ^ k * 2) - 1 ∧ ¬2 ^ (k + 3) ∣ P (2 ^ k * 2) - 1 := by
      have h_P_div : P (2 ^ k * 2) - 1 ≡ (P (2 ^ k) - 1) * (P (2 ^ k) + 1) [MOD 2 ^ (k + 3)] := by
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        cases le_total ( P ( 2 ^ k * 2 ) ) 1 <;> cases le_total ( P ( 2 ^ k ) ) 1 <;> simp_all +decide [ Nat.cast_sub ] ; ring;
        · interval_cases _ : P ( 2 ^ k * 2 ) <;> simp_all +decide;
          exact absurd ‹P ( 2 ^ k * 2 ) = 0› ( by exact ne_of_gt <| Nat.recOn ( 2 ^ k * 2 ) ( by decide ) fun n ihn => by rw [ show P ( n + 1 ) = P n * ( 2 * c n + 1 ) from rfl ] ; positivity );
        · ring;
      -- Let's simplify the goal using the properties of $c$ and $P$ further, considering the divisibility conditions for $P$.
      have h_P_div_simplified : 2 ^ (k + 2) ∣ (P (2 ^ k) - 1) * (P (2 ^ k) + 1) ∧ ¬2 ^ (k + 3) ∣ (P (2 ^ k) - 1) * (P (2 ^ k) + 1) := by
        obtain ⟨ a, ha ⟩ := ih.2.2.1; simp_all +decide [ pow_succ, mul_assoc ] ;
        norm_num [ mul_dvd_mul_iff_left ( by positivity : ( 2 ^ k : ℕ ) ≠ 0 ) ] at *;
        rw [ tsub_eq_iff_eq_add_of_le ( Nat.one_le_iff_ne_zero.mpr <| by aesop ) ] at ha ; aesop;
        · rcases Nat.even_or_odd' a with ⟨ b, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] at *;
        · rcases Nat.even_or_odd' a with ⟨ b, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ] at *;
          rcases k with ( _ | _ | _ | k ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod ] at *;
      rw [ Nat.dvd_iff_mod_eq_zero, Nat.dvd_iff_mod_eq_zero ] at *;
      exact ⟨ h_P_div.of_dvd ( pow_dvd_pow _ ( Nat.le_succ _ ) ) ▸ h_P_div_simplified.1, fun h => h_P_div_simplified.2 <| h_P_div.symm ▸ h ⟩;
    ring_nf at *; aesop;

/-
Show that $c_{2^{k+1}} \equiv c_{2^k}(1 + P_{2^k}) \pmod{c_{2^k}^2}$.
-/
theorem c_doubling (k : ℕ) : c (2^(k+1)) ≡ c (2^k) * (1 + P (2^k)) [MOD (c (2^k))^2] := by
  -- Apply the c_add_mod theorem with n = 2^k and m = 2^k.
  have h_cong : c (2^k + 2^k) ≡ c (2^k) + c (2^k) * P (2^k) [MOD (c (2^k))^2] := by
    convert c_add_mod ( 2 ^ k ) ( 2 ^ k ) using 1;
  grind

/-
Show that $b_{2^{k+1}} - 2b_{2^k}$ is divisible by $2^{2k+2}$ but not by $2^{2k+3}$.
-/
theorem main_result (k : ℕ) (hk : k ≥ 1) :
  (2^(2*k+2) ∣ (b (2^(k+1)) : ℤ) - 2 * b (2^k)) ∧ ¬ (2^(2*k+3) ∣ (b (2^(k+1)) : ℤ) - 2 * b (2^k)) := by
    -- Let $X = b_{2^{k+1}} - 2b_{2^k}$.
    set X := (b (2^(k+1)) : ℤ) - 2 * (b (2^k) : ℤ)
    have hX : 2 * X ≡ (c (2^k)) * (P (2^k) - 1) [ZMOD (c (2^k))^2] := by
      -- By definition of $c$, we know that $c_{2^{k+1}} \equiv c_{2^k}(1 + P_{2^k}) \pmod{c_{2^k}^2}$.
      have h_c_mod : (c (2 ^ (k + 1)) : ℤ) ≡ (c (2 ^ k) : ℤ) * (1 + (P (2 ^ k) : ℤ)) [ZMOD (c (2 ^ k) : ℤ)^2] := by
        norm_cast;
        convert c_doubling k using 1;
      convert h_c_mod.sub_right ( 2 * c ( 2 ^ k ) ) using 1 <;> ring!;
      unfold c; push_cast; ring;
    -- Since $v_2(c_{2^k}) = k+2$ and $v_2(P_{2^k} - 1) = k+1$, we have $v_2(c_{2^k}(P_{2^k} - 1)) = 2k+3$.
    have hv2_prod : (2^(2*k+3) : ℤ) ∣ (c (2^k)) * (P (2^k) - 1) ∧ ¬((2^(2*k+4) : ℤ) ∣ (c (2^k)) * (P (2^k) - 1)) := by
      -- From the induction hypothesis, we know that $v_2(c_{2^k}) = k+2$ and $v_2(P_{2^k} - 1) = k+1$.
      obtain ⟨hc, hc_not⟩ : (2^(k+2) : ℤ) ∣ (c (2^k) : ℤ) ∧ ¬((2^(k+3) : ℤ) ∣ (c (2^k) : ℤ)) := by
        have := combined_val k hk; norm_cast at *; aesop;
      obtain ⟨hp, hp_not⟩ : (2^(k+1) : ℤ) ∣ ((P (2^k)) - 1 : ℤ) ∧ ¬((2^(k+2) : ℤ) ∣ ((P (2^k)) - 1 : ℤ)) := by
        have := combined_val k hk; norm_cast at *; aesop;
        · rw [ Int.subNatNat_of_le ( Nat.one_le_iff_ne_zero.mpr <| by { exact ne_of_gt <| Nat.recOn ( 2 ^ k ) ( by decide ) fun n ihn => by { rw [ show P ( n + 1 ) = P n * ( 2 * c n + 1 ) from rfl ] ; positivity } } ) ] ; norm_cast;
        · rw [ Int.subNatNat_of_le ( Nat.one_le_iff_ne_zero.mpr <| by aesop ) ] at a ; norm_cast at *;
      obtain ⟨ a, ha ⟩ := hc; obtain ⟨ b, hb ⟩ := hp; aesop;
      · exact ⟨ a * b, by ring ⟩;
      · -- If $2^{2k+4} \mid 2^{2k+3} * a * b$, then $2 \mid a * b$.
        have h_div : 2 ∣ a * b := by
          obtain ⟨ d, hd ⟩ := a_1; exact ⟨ d, by { exact mul_left_cancel₀ ( pow_ne_zero ( 2 * k + 3 ) two_ne_zero ) <| by linear_combination hd } ⟩ ;
        exact hc_not ( mul_dvd_mul_left _ ( show 2 ∣ a from by exact Or.resolve_right ( Int.prime_two.dvd_mul.mp h_div ) fun h => hp_not <| mul_dvd_mul_left _ h ) );
    -- Since $c_{2^k}^2$ is divisible by $2^{2k+4}$, we have $2X \equiv c_{2^k}(P_{2^k} - 1) \pmod{2^{2k+4}}$.
    have h_mod : 2 * X ≡ (c (2^k)) * (P (2^k) - 1) [ZMOD (2^(2*k+4) : ℤ)] := by
      refine hX.of_dvd ?_;
      have := combined_val k hk; norm_cast at *; aesop;
      convert pow_dvd_pow_of_dvd left 2 using 1 ; ring;
    -- Therefore, $2X$ is divisible by $2^{2k+3}$ but not by $2^{2k+4}$.
    have h_div : (2^(2*k+3) : ℤ) ∣ 2 * X ∧ ¬((2^(2*k+4) : ℤ) ∣ 2 * X) := by
      rw [ Int.dvd_iff_emod_eq_zero, Int.dvd_iff_emod_eq_zero, h_mod ] ; aesop;
      exact Int.dvd_of_emod_eq_zero ( h_mod.of_dvd ( pow_dvd_pow _ ( Nat.le_succ _ ) ) ▸ Int.emod_eq_zero_of_dvd left );
    constructor <;> norm_num [ pow_succ', mul_dvd_mul_iff_left ] at * <;> tauto
