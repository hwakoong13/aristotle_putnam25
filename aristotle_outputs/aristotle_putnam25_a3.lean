/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 204d13a7-c04b-4456-b0a3-8a6d3ab0503c
-/

/-
We define the game on the grid graph $P_3^n$ where vertices are strings of length $n$ with digits $\{0, 1, 2\}$.
We define the `GridGraph` and the game states `Winning` and `Losing`.
We construct a matching strategy `partner` for the second player (Bob).
We prove that this strategy is valid and guarantees a win for Bob for all $n \ge 1$.
The main result is `bob_wins`, which states that the starting position is a Losing position for the first player.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Definitions of GridGraph and start vertex. GridGraph is the graph on strings of length n with digits 0,1,2 where edges connect strings differing by 1 in one position. start is the string of all 0s.
-/
/-- The grid graph P_3^n. Vertices are strings of length n with digits {0, 1, 2}.
    Two vertices are adjacent if they differ in exactly one coordinate by ±1. -/
def GridGraph (n : ℕ) : SimpleGraph (Fin n → Fin 3) :=
  SimpleGraph.fromRel (fun u v => ∃ i, (u i).val + 1 = (v i).val ∧ ∀ j, j ≠ i → u j = v j)

/-- The starting vertex (all zeros). -/
def start (n : ℕ) : Fin n → Fin 3 := fun _ => 0

/-
Winning and Losing positions defined mutually for a graph G.
Winning: exists a move to a Losing state.
Losing: all moves lead to a Winning state.
The state includes the set of visited vertices to ensure the game is finite and acyclic.
-/
section Game
variable {V : Type*} (G : SimpleGraph V)

mutual
  inductive Winning : Set V → V → Prop
    | win : ∀ (visited : Set V) (current : V) (next : V),
      G.Adj current next → next ∉ visited →
      Losing (visited ∪ {next}) next → Winning visited current

  inductive Losing : Set V → V → Prop
    | lose : ∀ (visited : Set V) (current : V),
      (∀ (next : V), G.Adj current next → next ∉ visited →
        Winning (visited ∪ {next}) next) → Losing visited current
end
end Game

/-
partner n v returns the matched vertex for v in the matching M.
If v is the start vertex (all 0s), it returns none.
The matching is defined recursively:
If the first digit is 0, match recursively on the rest.
If the first digit is 1, change it to 2.
If the first digit is 2, change it to 1.
-/
/-- The partner function for the matching strategy. -/
def partner : (n : ℕ) → (Fin n → Fin 3) → Option (Fin n → Fin 3)
| 0, _ => none
| n + 1, v =>
  if v 0 = 0 then
    (partner n (v ∘ Fin.succ)).map (Fin.cons 0)
  else if v 0 = 1 then
    some (Fin.cons 2 (v ∘ Fin.succ))
  else
    some (Fin.cons 1 (v ∘ Fin.succ))

/-
The partner function is symmetric: if u is paired with v, then v is paired with u.
-/
theorem partner_symmetric (n : ℕ) (u v : Fin n → Fin 3) :
    partner n u = some v → partner n v = some u := by
      induction' n with n ih;
      · native_decide +revert;
      · unfold partner; aesop;
        · use ( u ∘ Fin.succ ) ; aesop;
          · convert ih _ _ left using 1;
          · ext i; induction i using Fin.inductionOn <;> aesop;
        · ext ( _ | i ) <;> simp_all +decide [ Fin.cons ];
          grind +ring;
        · ext i; induction i using Fin.inductionOn <;> aesop;

/-
If partner n u = some v, then u and v are adjacent in GridGraph n.
-/
theorem partner_adj (n : ℕ) (u v : Fin n → Fin 3) :
    partner n u = some v → (GridGraph n).Adj u v := by
      induction' n with n ih;
      · decide +revert;
      · unfold GridGraph;
        unfold partner; aesop;
        any_goals have := congr_fun a 0; simp_all +decide;
        · specialize ih _ _ left ; unfold GridGraph at ih ; aesop;
        · specialize ih _ _ left; unfold GridGraph at ih; aesop;
          · refine Or.inl ⟨ Fin.succ w_1, ?_, ?_ ⟩ <;> aesop;
            induction j using Fin.inductionOn <;> aesop;
          · refine Or.inr ⟨ Fin.succ w_1, ?_, ?_ ⟩ <;> aesop;
            induction j using Fin.inductionOn <;> aesop;
        · exact Or.inl ⟨ 0, by simp +decide [ h_1 ], fun j hj => by cases j using Fin.inductionOn <;> aesop ⟩;
        · refine' Or.inr ⟨ 0, _, _ ⟩ <;> simp_all +decide [ Fin.forall_fin_succ ];
          grind

/-
The partner of the start vertex is none.
-/
theorem partner_start_none (n : ℕ) : partner n (start n) = none := by
  induction' n with n ih;
  · exact?;
  · -- By definition of partner, we have:
    simp [partner];
    unfold start; aesop;

/-
Every vertex except the start vertex has a partner.
-/
theorem partner_some (n : ℕ) (v : Fin n → Fin 3) :
    v ≠ start n → (partner n v).isSome := by
      induction n <;> aesop;
      · exact False.elim <| a <| Subsingleton.elim _ _;
      · unfold partner; specialize a ( v ∘ Fin.succ ) ; aesop;
        exact a ( by intro H; exact a_1 <| by ext i; induction i using Fin.inductionOn <;> simp_all +decide [ funext_iff, start ] )

/-
Definition of MatchedSet: a set S containing start where every non-start element has its partner in S.
-/
/-- A set of vertices is a "MatchedSet" if it contains the start vertex,
    and for every other vertex in the set, its partner is also in the set. -/
def MatchedSet (n : ℕ) (S : Set (Fin n → Fin 3)) : Prop :=
  start n ∈ S ∧ ∀ x ∈ S, x ≠ start n → ∃ y ∈ S, partner n x = some y

/-
If S is a MatchedSet and current is in S, then the position (S, current) is Losing for the current player (Alice).
-/
theorem matched_set_losing (n : ℕ) (S : Set (Fin n → Fin 3)) (current : Fin n → Fin 3) :
    MatchedSet n S → current ∈ S → Losing (GridGraph n) S current := by
      aesop;
      induction' k : ( Finset.univ.filter fun x : Fin n → Fin 3 => x ∉ S ).card using Nat.strong_induction_on with k ih generalizing current S;
      constructor ; aesop;
      -- Let response = partner n next.
      obtain ⟨response, hresponse⟩ : ∃ response, partner n next = some response := by
        have h_partner_some : next ≠ start n := by
          aesop;
          exact a_3 a.1;
        exact Option.isSome_iff_exists.mp ( partner_some n next h_partner_some );
      -- We need to show that response is not in S ∪ {next}.
      have hresponse_not_in_S_union_next : response ∉ S ∪ {next} := by
        have hresponse_not_in_S : response ∉ S := by
          bound;
          have := partner_symmetric n next response hresponse;
          have := a.2 response a_4; aesop;
          exact absurd this_1 ( by rw [ partner_start_none ] ; aesop );
        have := partner_adj n next response hresponse; aesop;
      -- We need to show that response is in the set S ∪ {next, response}.
      have hresponse_in_S_union_next_response : MatchedSet n (S ∪ {next, response}) := by
        constructor <;> simp_all +decide [ MatchedSet ];
        have := partner_symmetric n next response hresponse; aesop;
      -- We need to show that the cardinality of the complement of S ∪ {next, response} is less than the cardinality of the complement of S.
      have hcard_complement : (Finset.univ.filter fun x => x ∉ S ∪ {next, response}).card < (Finset.univ.filter fun x => x ∉ S).card := by
        refine' Finset.card_lt_card _;
        simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
        exact ⟨ response, hresponse_not_in_S_union_next.2, by tauto ⟩;
      specialize ih _ hcard_complement ( S ∪ { next, response } ) response hresponse_in_S_union_next_response ; aesop;
      constructor;
      convert partner_adj n next response hresponse using 1;
      · aesop;
      · convert ih using 1 ; ext ; aesop

/-
Bob has a winning strategy for the game on GridGraph n for n ≥ 1.
This is equivalent to the initial state being Losing for Alice.
-/
/-- Bob (the second player) has a winning strategy.
    This means the initial state is a Losing state for Alice. -/
theorem bob_wins (n : ℕ) (h : n ≥ 1) : Losing (GridGraph n) {start n} (start n) := by
  apply matched_set_losing;
  · constructor <;> aesop;
  · trivial
