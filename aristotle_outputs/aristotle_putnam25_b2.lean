/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 31dd01bb-af45-4f94-b529-620feb3c19f9
-/

/-
This file proves that for a strictly increasing continuous function f : [0, 1] → [0, ∞), the x-coordinate of the centroid of the region under the curve is strictly less than the x-coordinate of the centroid of the solid of revolution generated by rotating the region about the x-axis.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Let $f:[0,1] \to [0,\infty)$ be strictly increasing and continuous. Let $x_1$ be the centroid of the region under $f$, and $x_2$ be the centroid of the solid of revolution of $f$. Then $x_1 < x_2$.
-/
open Set MeasureTheory intervalIntegral

variable {f : ℝ → ℝ}

theorem centroid_inequality
  (hf_cont : ContinuousOn f (Set.Icc 0 1))
  (hf_inc : StrictMonoOn f (Set.Icc 0 1))
  (hf_pos : ∀ x ∈ Set.Icc 0 1, 0 ≤ f x) :
  let A := ∫ x in (0:ℝ)..1, f x
  let M1 := ∫ x in (0:ℝ)..1, x * f x
  let x1 := M1 / A
  let V := ∫ x in (0:ℝ)..1, f x ^ 2
  let M2 := ∫ x in (0:ℝ)..1, x * f x ^ 2
  let x2 := M2 / V
  x1 < x2 := by
    -- Rearranging, we want to show $(\int_0^1 x f(x)^2 dx)(\int_0^1 f(x) dx) - (\int_0^1 x f(x) dx)(\int_0^1 f(x)^2 dx) > 0$.
    suffices h_suff : (∫ x in (0)..1, x * (f x)^2) * (∫ x in (0)..1, f x) - (∫ x in (0)..1, x * f x) * (∫ x in (0)..1, (f x)^2) > 0 by
      by_cases hA : ∫ x in ( 0 : ℝ )..1, f x = 0 <;> by_cases hV : ∫ x in ( 0 : ℝ )..1, f x ^ 2 = 0 <;> aesop;
      · exact False.elim <| h_suff.not_le <| mul_nonneg ( intervalIntegral.integral_nonneg ( by norm_num ) fun x hx => mul_nonneg hx.1 <| hf_pos x hx.1 hx.2 ) <| intervalIntegral.integral_nonneg ( by norm_num ) fun x hx => sq_nonneg _;
      · rw [ intervalIntegral.integral_of_le zero_le_one ] at *;
        rw [ MeasureTheory.integral_eq_zero_iff_of_nonneg_ae ] at hV;
        · rw [ MeasureTheory.integral_eq_zero_of_ae ] at hA <;> aesop;
          filter_upwards [ hV ] with x hx using sq_eq_zero_iff.mp hx;
        · exact Filter.Eventually.of_forall fun x => sq_nonneg _;
        · exact ContinuousOn.integrableOn_Icc ( hf_cont.pow 2 ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
      · rw [ div_lt_div_iff₀ ] <;> first | linarith | exact lt_of_le_of_ne ( by exact intervalIntegral.integral_nonneg ( by norm_num ) fun x hx => hf_pos x hx.1 hx.2 ) ( Ne.symm hA ) | exact lt_of_le_of_ne ( by exact intervalIntegral.integral_nonneg ( by norm_num ) fun x hx => sq_nonneg _ ) ( Ne.symm hV ) ;
    -- We can rewrite the numerator as $\int_0^1 \int_0^1 (x - y) f(x) f(y) (f(x) - f(y)) \, dx \, dy$.
    have h_num : (∫ x in (0)..1, x * (f x)^2) * (∫ x in (0)..1, f x) - (∫ x in (0)..1, x * f x) * (∫ x in (0)..1, (f x)^2) = (∫ x in (0)..1, ∫ y in (0)..1, (x - y) * f x * f y * (f x - f y)) / 2 := by
      -- Expand the double integral on the right-hand side.
      have h_expand : ∫ x in (0)..1, ∫ y in (0)..1, (x - y) * f x * f y * (f x - f y) = ∫ x in (0)..1, ∫ y in (0)..1, (x * f x^2 * f y - x * f x * f y^2 - y * f x^2 * f y + y * f x * f y^2) := by
        exact intervalIntegral.integral_congr fun x _ => intervalIntegral.integral_congr fun y _ => by ring;
      -- By Fubini's theorem, we can interchange the order of integration.
      have h_fubini : ∫ x in (0)..1, ∫ y in (0)..1, (x * f x^2 * f y - x * f x * f y^2 - y * f x^2 * f y + y * f x * f y^2) = (∫ x in (0)..1, x * f x^2) * (∫ y in (0)..1, f y) - (∫ x in (0)..1, x * f x) * (∫ y in (0)..1, f y^2) - (∫ x in (0)..1, f x^2) * (∫ y in (0)..1, y * f y) + (∫ x in (0)..1, f x) * (∫ y in (0)..1, y * f y^2) := by
        have h_fubini : ∀ x ∈ Set.Icc 0 1, ∫ y in (0)..1, (x * f x^2 * f y - x * f x * f y^2 - y * f x^2 * f y + y * f x * f y^2) = (x * f x^2) * (∫ y in (0)..1, f y) - (x * f x) * (∫ y in (0)..1, f y^2) - (∫ y in (0)..1, y * f y) * (f x^2) + (∫ y in (0)..1, y * f y^2) * (f x) := by
          intro x hx; rw [ intervalIntegral.integral_add, intervalIntegral.integral_sub, intervalIntegral.integral_sub ] <;> norm_num;
          any_goals apply_rules [ ContinuousOn.intervalIntegrable ];
          any_goals apply_rules [ ContinuousOn.sub, ContinuousOn.mul, continuousOn_id, continuousOn_const ];
          any_goals norm_num [ hf_cont ];
          norm_num [ mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul ];
        rw [ intervalIntegral.integral_congr fun x hx => h_fubini x <| by simpa using hx ];
        rw [ intervalIntegral.integral_add, intervalIntegral.integral_sub ] <;> norm_num;
        · rw [ intervalIntegral.integral_sub ] <;> norm_num ; ring;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            simpa using ContinuousOn.mul ( ContinuousOn.mul continuousOn_id ( hf_cont.pow 2 ) ) continuousOn_const;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            simpa using ContinuousOn.mul ( continuousOn_id.mul hf_cont ) continuousOn_const;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          simpa using ContinuousOn.sub ( ContinuousOn.mul ( continuousOn_id.mul ( hf_cont.pow 2 ) ) continuousOn_const ) ( ContinuousOn.mul ( continuousOn_id.mul hf_cont ) continuousOn_const );
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          simpa using continuousOn_const.mul ( hf_cont.pow 2 );
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          simpa using ContinuousOn.sub ( ContinuousOn.sub ( ContinuousOn.mul ( continuousOn_id.mul ( hf_cont.pow 2 ) ) continuousOn_const ) ( ContinuousOn.mul ( continuousOn_id.mul hf_cont ) continuousOn_const ) ) ( ContinuousOn.mul continuousOn_const ( hf_cont.pow 2 ) );
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          simpa using continuousOn_const.mul hf_cont;
      norm_num [ ← pow_two ] at * ; linarith;
    -- Since $f$ is strictly increasing, $(x - y) f(x) f(y) (f(x) - f(y)) > 0$ for $x \ne y$.
    have h_pos : ∀ x ∈ Set.Ioo (0 : ℝ) 1, ∀ y ∈ Set.Ioo (0 : ℝ) 1, x ≠ y → (x - y) * f x * f y * (f x - f y) > 0 := by
      intro x hx y hy hxy; cases lt_or_gt_of_ne hxy <;> simp_all +decide [ mul_assoc, mul_pos_iff ] ;
      · bound;
        exact Or.inr ( mul_neg_of_pos_of_neg ( hf_pos x left.le right.le |> fun hx => lt_of_le_of_ne hx ( Ne.symm <| by linarith [ hf_inc ( show 0 ∈ Set.Icc 0 1 by norm_num ) ( show x ∈ Set.Icc 0 1 by constructor <;> linarith ) <| by linarith, hf_pos 0 ( by norm_num ) ( by norm_num ) ] ) ) <| mul_neg_of_pos_of_neg ( hf_pos y left_1.le right_1.le |> fun hy => lt_of_le_of_ne hy ( Ne.symm <| by linarith [ hf_inc ( show 0 ∈ Set.Icc 0 1 by norm_num ) ( show y ∈ Set.Icc 0 1 by constructor <;> linarith ) <| by linarith, hf_pos 0 ( by norm_num ) ( by norm_num ) ] ) ) <| sub_neg_of_lt <| hf_inc ( show x ∈ Set.Icc 0 1 by constructor <;> linarith ) ( show y ∈ Set.Icc 0 1 by constructor <;> linarith ) h );
      · exact Or.inl ⟨ lt_of_le_of_lt ( hf_pos y hy.1.le hy.2.le ) ( hf_inc ⟨ by linarith, by linarith ⟩ ⟨ by linarith, by linarith ⟩ ( by linarith ) ), Or.inl ⟨ lt_of_le_of_lt ( hf_pos 0 ( by norm_num ) ( by norm_num ) ) ( hf_inc ⟨ by linarith, by linarith ⟩ ⟨ by linarith, by linarith ⟩ ( by linarith ) ), hf_inc ⟨ by linarith, by linarith ⟩ ⟨ by linarith, by linarith ⟩ ( by linarith ) ⟩ ⟩;
    -- Since the integrand is positive on a set of positive measure, the integral must be positive.
    have h_int_pos : 0 < ∫ x in Set.Ioo (0 : ℝ) 1, ∫ y in Set.Ioo (0 : ℝ) 1, (x - y) * f x * f y * (f x - f y) := by
      rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
      · simp +zetaDelta at *;
        refine' ( lt_of_lt_of_le _ ( MeasureTheory.measure_mono _ ) );
        rotate_left;
        exact Set.Ioo 0 ( 1 / 2 );
        · intro x hx;
          refine' ⟨ ne_of_gt _, hx.1, hx.2.trans_le <| by norm_num ⟩;
          rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
          · simp +zetaDelta at *;
            refine' ( lt_of_lt_of_le _ ( MeasureTheory.measure_mono _ ) );
            rotate_left;
            exact Set.Ioo 0 x;
            · intro y hy; aesop;
              · linarith;
              · linarith [ hf_inc ( show 0 ∈ Set.Icc 0 1 by norm_num ) ( show x ∈ Set.Icc 0 1 by constructor <;> linarith ) ( by linarith ), hf_pos 0 ( by norm_num ) ( by norm_num ) ];
              · exact absurd a ( ne_of_gt ( lt_of_le_of_lt ( hf_pos 0 ( by norm_num ) ( by norm_num ) ) ( hf_inc ( by norm_num ) ( by constructor <;> linarith ) ( by linarith ) ) ) );
              · linarith [ hf_inc ( show y ∈ Set.Icc 0 1 by constructor <;> linarith ) ( show x ∈ Set.Icc 0 1 by constructor <;> linarith ) ( by linarith ) ];
              · norm_num at * ; linarith;
            · aesop;
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with y hy;
            by_cases hxy : x = y <;> aesop;
            exact le_of_lt ( h_pos x left ( right.trans_le ( by norm_num ) ) y left_1 right_1 hxy );
          · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( ContinuousOn.mul ( ContinuousOn.mul ( continuousOn_const.sub continuousOn_id ) continuousOn_const ) ( hf_cont.mono ( Set.Icc_subset_Icc le_rfl ( by norm_num ) ) ) ) ( continuousOn_const.sub ( hf_cont.mono ( Set.Icc_subset_Icc le_rfl ( by norm_num ) ) ) ) ) |> fun h => h.mono_set ( Set.Ioo_subset_Icc_self );
        · norm_num;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with x hx;
        exact MeasureTheory.setIntegral_nonneg measurableSet_Ioo fun y hy => if hxy : x = y then by norm_num [ hxy ] else le_of_lt ( h_pos x hx y hy hxy );
      · -- The function inside the integral is continuous on the compact interval $[0, 1]$, hence it is integrable.
        have h_cont : ContinuousOn (fun x => ∫ y in Set.Ioo (0 : ℝ) 1, (x - y) * f x * f y * (f x - f y)) (Set.Icc 0 1) := by
          have h_cont : ContinuousOn (fun x => ∫ y in (0 : ℝ)..1, (x - y) * f x * f y * (f x - f y)) (Set.Icc 0 1) := by
            have h_cont_integrand : ContinuousOn (fun p : ℝ × ℝ => (p.1 - p.2) * f p.1 * f p.2 * (f p.1 - f p.2)) (Set.Icc 0 1 ×ˢ Set.Icc 0 1) := by
              apply_rules [ ContinuousOn.mul, ContinuousOn.sub, continuousOn_fst, continuousOn_snd, continuousOn_const ];
              · exact hf_cont.comp continuousOn_fst fun x hx => hx.1;
              · exact hf_cont.comp continuousOn_snd fun x hx => hx.2;
              · exact hf_cont.comp continuousOn_fst fun x hx => hx.1;
              · exact hf_cont.comp continuousOn_snd fun x hx => hx.2
            intro x hx;
            refine' intervalIntegral.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
            use fun y => ( SupSet.sSup ( Set.image ( fun p : ℝ × ℝ => |( p.1 - p.2 ) * f p.1 * f p.2 * ( f p.1 - f p.2 )| ) ( Set.Icc 0 1 ×ˢ Set.Icc 0 1 ) ) );
            · norm_num +zetaDelta at *;
              filter_upwards [ self_mem_nhdsWithin ] with n hn;
              exact ContinuousOn.aestronglyMeasurable ( by exact ContinuousOn.mul ( ContinuousOn.mul ( ContinuousOn.mul ( continuousOn_const.sub continuousOn_id ) continuousOn_const ) ( hf_cont.mono ( Set.Ioc_subset_Icc_self ) ) ) ( continuousOn_const.sub ( hf_cont.mono ( Set.Ioc_subset_Icc_self ) ) ) ) measurableSet_Ioc;
            · filter_upwards [ self_mem_nhdsWithin ] with n hn;
              filter_upwards [ ] with y hy using le_csSup ( IsCompact.bddAbove ( isCompact_Icc.prod CompactIccSpace.isCompact_Icc |> IsCompact.image_of_continuousOn <| h_cont_integrand.abs ) ) <| Set.mem_image_of_mem _ <| Set.mk_mem_prod hn <| by constructor <;> cases Set.mem_uIoc.mp hy <;> linarith [ hn.1, hn.2 ] ;
            · norm_num;
            · refine' Filter.Eventually.of_forall fun y hy => _;
              exact Filter.Tendsto.mul ( Filter.Tendsto.mul ( Filter.Tendsto.mul ( continuousWithinAt_id.sub continuousWithinAt_const ) ( hf_cont.continuousWithinAt hx ) ) tendsto_const_nhds ) ( hf_cont.continuousWithinAt hx |> Filter.Tendsto.sub <| tendsto_const_nhds );
          simpa only [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_Ioc_eq_integral_Ioo ] using h_cont;
        exact h_cont.integrableOn_Icc.mono_set <| Set.Ioo_subset_Icc_self;
    simp_all +decide [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_Ioc_eq_integral_Ioo ]
