/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c73a2f8c-8c05-46a3-b04d-34884e739ced
-/

/-
We prove that for a prime $p > 3$, the number of descents in the sequence of modular inverses $I(k) = k^{-1} \pmod p$ for $k \in \{1, \dots, p-2\}$ is greater than $p/4 - 1$.
We define $I(k)$ as the unique integer in $\{1, \dots, p-1\}$ such that $k \cdot I(k) \equiv 1 \pmod p$.
We define the set of descents $D = \{k \in \{1, \dots, p-2\} \mid I(k+1) < I(k)\}$.
We derive an identity relating the number of descents to the sum $S = \sum_{k=1}^{p-2} (k(k+1))^{-1} \pmod p$.
Specifically, we show $|D| = p - 2 - (S + p - 2)/p$.
We then bound $S$ by analyzing the distribution of $y_k = (k(k+1))^{-1} \pmod p$.
We show $S \le (3p^2 - 8p + 17)/4$ for $p > 13$.
Using this bound, we prove $|D| > p/4 - 1$ for $p > 13$.
For $p \le 13$, we verify the claim by direct computation for primes $5, 7, 11, 13$.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

/-
Definitions for the problem. I(p, k) is the modular inverse of k mod p. descents(p) is the set of k where I(p, k+1) < I(p, k). y(p, k) is the modular inverse of k(k+1) mod p.
-/
open ZMod

def I (p : ℕ) (k : ℕ) : ℕ := (k : ZMod p)⁻¹.val

def descents (p : ℕ) : Finset ℕ :=
  Finset.filter (fun k => I p (k + 1) < I p k) (Finset.Icc 1 (p - 2))

noncomputable def y (p : ℕ) (k : ℕ) : ℕ := ((k : ZMod p) * (k + 1))⁻¹.val

/-
The difference I(k+1) - I(k) is equal to -y(k) if I(k+1) < I(k), and p - y(k) otherwise.
-/
lemma diff_eq (p : ℕ) [Fact p.Prime] (hp : p > 3) (k : ℕ) (hk : k ∈ Finset.Icc 1 (p - 2)) :
    (I p (k + 1) : ℤ) - I p k = if I p (k + 1) < I p k then -(y p k : ℤ) else (p : ℤ) - y p k := by
  -- By definition of $I$ and $y$, we know that $I(k+1) - I(k) \equiv -y(k) \pmod{p}$.
  have h_cong : (I p (k + 1) : ℤ) - (I p k : ℤ) ≡ -((y p k) : ℤ) [ZMOD p] := by
    simp +decide [ ← ZMod.intCast_eq_intCast_iff, I, y ];
    rw [ inv_sub_inv ] <;> ring <;> norm_num;
    · rw [ ← mul_inv ] ; ring;
    · norm_cast;
      rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by linarith [ Finset.mem_Icc.mp hk ] ) ( by linarith [ Finset.mem_Icc.mp hk, Nat.sub_add_cancel ( by linarith : 2 ≤ p ) ] );
    · rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( Finset.mem_Icc.mp hk |>.1 ) ( lt_of_le_of_lt ( Finset.mem_Icc.mp hk |>.2 ) ( Nat.sub_lt ( by linarith ) ( by linarith ) ) );
  split_ifs with h_1 <;> simp_all +decide [ Int.ModEq ];
  · rw [ Int.emod_eq_emod_iff_emod_sub_eq_zero ] at h_cong;
    -- Since $I(k+1) < I(k)$, we have $I(k+1) - I(k) \equiv -y(k) \pmod{p}$ implies $I(k+1) - I(k) = -y(k)$.
    have h_diff_neg : (I p (k + 1) : ℤ) - (I p k : ℤ) + (y p k : ℤ) < p := by
      linarith [ show ( I p ( k + 1 ) : ℤ ) < p from mod_cast Nat.lt_of_lt_of_le ( ZMod.val_lt _ ) ( by linarith ), show ( I p k : ℤ ) < p from mod_cast Nat.lt_of_lt_of_le ( ZMod.val_lt _ ) ( by linarith ), show ( y p k : ℤ ) < p from mod_cast Nat.lt_of_lt_of_le ( ZMod.val_lt _ ) ( by linarith ) ];
    have h_diff_neg : (I p (k + 1) : ℤ) - (I p k : ℤ) + (y p k : ℤ) > -p := by
      linarith [ show ( I p ( k + 1 ) : ℤ ) ≥ 0 by positivity, show ( I p k : ℤ ) < p by exact_mod_cast ( show I p k < p from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by { haveI := Fact.mk ( Fact.out : Nat.Prime p ) ; exact ZMod.val_lt _ } ) ) ) ) ) ) ) ) ) ) ), show ( y p k : ℤ ) ≥ 0 by positivity ];
    obtain ⟨ m, hm ⟩ := Int.modEq_zero_iff_dvd.mp h_cong; nlinarith [ show m = 0 by nlinarith ] ;
  · -- Since $I(k+1) > I(k)$, we have $I(k+1) - I(k) = p - y(k)$.
    have h_eq : (I p (k + 1) : ℤ) - (I p k : ℤ) = p - (y p k : ℤ) := by
      have h_diff_range : (0 : ℤ) < (I p (k + 1) : ℤ) - (I p k : ℤ) ∧ (I p (k + 1) : ℤ) - (I p k : ℤ) < p := by
        aesop;
        · refine' lt_of_le_of_ne h_1 _;
          intro h_eq
          have h_contra : (k : ZMod p)⁻¹ = (k + 1 : ZMod p)⁻¹ := by
            have := ZMod.val_injective p h_eq; aesop;
          rw [ inv_inj ] at h_contra ; aesop;
        · linarith [ show ( I p ( k + 1 ) : ℤ ) < p from mod_cast Nat.lt_of_lt_of_le ( ZMod.val_lt _ ) ( by linarith ), show ( I p k : ℤ ) ≥ 0 from mod_cast Nat.zero_le _ ] ;
      rw [ Int.emod_eq_emod_iff_emod_sub_eq_zero ] at h_cong ; aesop;
      obtain ⟨ a, ha ⟩ := h_cong; nlinarith [ show a = 1 by nlinarith [ show ( y p k : ℤ ) < p from Nat.cast_lt.mpr <| show y p k < p from by { exact ( show ( ( y p k : ℕ ) : ℕ ) < p from ( by { exact ( by { haveI := Fact.mk ( Fact.out : Nat.Prime p ) ; exact ZMod.val_lt _ } ) } ) ) } ] ] ;
    exact h_eq

/-
I(p, 1) = 1.
-/
def S (p : ℕ) : ℕ := ∑ k ∈ Finset.Icc 1 (p - 2), y p k

lemma I_one (p : ℕ) [Fact p.Prime] (hp : p > 3) : I p 1 = 1 := by
  -- By definition of $I$, we know that $I(p, 1) = 1^{-1} = 1$.
  simp [I];
  rcases p with ( _ | _ | p ) <;> trivial

/-
I(p, p-1) = p-1.
-/
lemma I_sub_one (p : ℕ) [Fact p.Prime] (hp : p > 3) : I p (p - 1) = p - 1 := by
  unfold I;
  norm_num [ Nat.cast_pred ( show 1 ≤ p by linarith ) ];
  rcases p with ( _ | _ | p ) <;> aesop

/-
The sum of differences I(k+1) - I(k) is p-2.
-/
lemma sum_diff_eq (p : ℕ) [Fact p.Prime] (hp : p > 3) :
    ∑ k ∈ Finset.Icc 1 (p - 2), ((I p (k + 1) : ℤ) - I p k) = p - 2 := by
  -- The sum is telescoping: $\sum_{k=1}^{p-2} (I(k+1) - I(k)) = I(p-1) - I(1) = (p-1) - 1 = p-2$.
  have h_telescope : ∑ k ∈ Finset.Icc 1 (p - 2), ((I p (k + 1) : ℤ) - (I p k : ℤ)) = (I p (p - 1) : ℤ) - (I p 1 : ℤ) := by
    erw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num;
    rw [ Finset.sum_range_succ, Finset.sum_range_succ' ] ; norm_num ; ring;
    rw [ show 1 + ( p - 2 ) = p - 1 by omega ];
  norm_num +zetaDelta at *;
  rw [ h_telescope, I_sub_one, I_one ];
  · rw [ Nat.cast_sub ] <;> norm_num ; linarith;
    linarith;
  · linarith;
  · linarith

/-
The number of descents is p - 2 - (S + p - 2) / p.
-/
lemma card_descents_eq (p : ℕ) [Fact p.Prime] (hp : p > 3) :
    (descents p).card = p - 2 - (S p + p - 2) / p := by
  -- Let $D$ be the set of descents and $A$ be the set of ascents.
  set D := descents p
  set A := Finset.Icc 1 (p - 2) \ D;
  -- By definition of $D$ and $A$, we have $\sum_{k \in D} (-y_k) + \sum_{k \in A} (p - y_k) = p - 2$.
  have h_sum : (∑ k ∈ D, -(y p k : ℤ)) + (∑ k ∈ A, (p - y p k : ℤ)) = (p - 2 : ℤ) := by
    have h_sum : ∑ k ∈ Finset.Icc 1 (p - 2), ((I p (k + 1) : ℤ) - I p k) = ∑ k ∈ D, -(y p k : ℤ) + ∑ k ∈ A, (p - y p k : ℤ) := by
      rw [ ← Finset.sum_sdiff ( show D ⊆ Finset.Icc 1 ( p - 2 ) from Finset.filter_subset _ _ ) ];
      rw [ add_comm, Finset.sum_congr rfl ];
      congr! 1;
      · refine' Finset.sum_congr rfl fun x hx => _;
        have := diff_eq p hp x;
        aesop;
        exact False.elim <| right <| Finset.mem_filter.mpr ⟨ Finset.mem_Icc.mpr ⟨ left, right_1 ⟩, a ⟩;
      · aesop;
        rw [ diff_eq p hp x ( Finset.mem_filter.mp a |>.1 ) ] ; aesop;
        exact absurd a_1 ( not_le_of_gt ( Finset.mem_filter.mp a |>.2 ) );
    rw [ ← h_sum, sum_diff_eq ];
    linarith;
  -- Therefore, $p|A| - S = p - 2$, which implies $p|A| = S + p - 2$.
  have h_eq : (p : ℤ) * A.card = (S p + p - 2 : ℤ) := by
    unfold S; simp_all +decide [ Finset.sum_add_distrib, Finset.mul_sum _ _ _ ] ;
    rw [ ← Finset.sum_sdiff ( Finset.subset_iff.mpr <| show D ⊆ Finset.Icc 1 ( p - 2 ) from Finset.filter_subset _ _ ) ] at * ; linarith;
  -- Therefore, $|A| = \frac{S + p - 2}{p}$.
  have h_card_A : A.card = (S p + p - 2) / p := by
    exact Eq.symm ( Nat.div_eq_of_eq_mul_left ( Nat.Prime.pos Fact.out ) <| Nat.sub_eq_of_eq_add <| by linarith );
  rw [ ← h_card_A, Finset.card_sdiff ] ; aesop;
  rw [ show descents p ∩ Finset.Icc 1 ( p - 2 ) = descents p from Finset.inter_eq_left.mpr <| Finset.filter_subset _ _ ] ; rw [ Nat.sub_sub_self <| show ( descents p ).card ≤ p - 2 from le_trans ( Finset.card_le_card <| Finset.filter_subset _ _ ) <| by simpa ]

/-
y(p, k) is symmetric: y(p, k) = y(p, p-1-k).
-/
lemma y_symm (p : ℕ) [Fact p.Prime] (hp : p > 3) (k : ℕ) (hk : k ∈ Finset.Icc 1 (p - 2)) :
    y p k = y p (p - 1 - k) := by
  unfold y; aesop;
  rw [ Nat.cast_sub <| by omega, Nat.cast_sub <| by omega ] ; ring;
  aesop;
  grind

/-
y(p, 1) = (p+1)/2.
-/
lemma y_one (p : ℕ) [Fact p.Prime] (hp : p > 3) : y p 1 = (p + 1) / 2 := by
  -- By definition of y, we have y(p, 1) = ((1 * 2)⁻¹ : (ZMod p)).val.
  unfold y
  simp;
  have h_two_inv : (2 : ZMod p) * ((p + 1) / 2 : ℕ) = 1 := by
    norm_cast;
    norm_num [ Nat.mul_div_cancel' ( show 2 ∣ p + 1 from even_iff_two_dvd.mp ( by simpa [ parity_simps ] using Nat.Prime.odd_of_ne_two Fact.out ( by linarith ) ) ) ];
  rw [ inv_eq_of_mul_eq_one_right ] ; aesop;
  exact ZMod.val_cast_of_lt ( show ( p + 1 ) / 2 < p from Nat.div_lt_of_lt_mul <| by linarith );
  linear_combination' h_two_inv

/-
y(p, (p-1)/2) = p-4.
-/
lemma y_mid (p : ℕ) [Fact p.Prime] (hp : p > 5) : y p ((p - 1) / 2) = p - 4 := by
  -- We'll use that $y(p, k) = y(p, p-1-k)$ and that $y(p, 1) = (p+1)/2$.
  have hy_half : (( ((p - 1) / 2 : ℕ) * (((p - 1) / 2 : ℕ) + 1) : ZMod p )⁻¹ : ZMod p) = -4 := by
    rw [ Nat.cast_div ] <;> norm_num;
    · norm_num [ Nat.cast_sub ( show 1 ≤ p by linarith ) ];
      grind;
    · exact even_iff_two_dvd.mp ( Nat.Prime.even_sub_one Fact.out ( by linarith ) );
    · erw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by linarith ) ( by linarith );
  unfold y;
  rw [ hy_half, ZMod.neg_val ] ;
  rcases p with ( _ | _ | _ | _ | _ | p ) <;> trivial

/-
S(p) can be decomposed into 2 times the sum of the first half plus the middle term.
-/
lemma S_decomp (p : ℕ) [Fact p.Prime] (hp : p > 3) :
    S p = 2 * (∑ k ∈ Finset.Icc 1 ((p - 3) / 2), y p k) + y p ((p - 1) / 2) := by
  rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num;
  · exact absurd ( Fact.out ( p := Nat.Prime ( 2*c ) ) ) ( Nat.not_prime_mul ( by norm_num ) ( by linarith ) );
  · -- Split the sum into two parts: one over the first half and one over the second half.
    have h_split : ∑ k ∈ Finset.Icc 1 (2 * c - 1), y (2 * c + 1) k = ∑ k ∈ Finset.Icc 1 (c - 1), y (2 * c + 1) k + ∑ k ∈ Finset.Icc (c + 1) (2 * c - 1), y (2 * c + 1) k + y (2 * c + 1) c := by
      have h_split : Finset.Icc 1 (2 * c - 1) = Finset.Icc 1 (c - 1) ∪ Finset.Icc (c + 1) (2 * c - 1) ∪ {c} := by
        ext ; aesop <;> omega;
      rw [ h_split, Finset.sum_union, Finset.sum_union ] <;> norm_num;
      · exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ Finset.mem_Icc.mp hx₁, Finset.mem_Icc.mp hx₂, Nat.sub_add_cancel ( by linarith : 1 ≤ c ) ] ;
      · exact fun _ => by linarith;
    -- By symmetry of $y$, we have $\sum_{k=c+1}^{2c-1} y(p, k) = \sum_{k=1}^{c-1} y(p, k)$.
    have h_symm_sum : ∑ k ∈ Finset.Icc (c + 1) (2 * c - 1), y (2 * c + 1) k = ∑ k ∈ Finset.Icc 1 (c - 1), y (2 * c + 1) k := by
      apply Finset.sum_bij (fun k hk => 2 * c - k);
      · aesop <;> omega;
      · intro a₁ ha₁ a₂ ha₂ h; rw [ tsub_right_inj ] at h <;> linarith [ Finset.mem_Icc.mp ha₁, Finset.mem_Icc.mp ha₂, Nat.sub_add_cancel ( by linarith : 1 ≤ 2 * c ) ] ;
      · simp +zetaDelta at *;
        exact fun b hb₁ hb₂ => ⟨ 2 * c - b, ⟨ by omega, by omega ⟩, by omega ⟩;
      · aesop;
        convert y_symm ( 2 * c + 1 ) ( by linarith ) a ( Finset.mem_Icc.mpr ⟨ by linarith, by omega ⟩ ) using 1;
    unfold S; aesop;
    cases c <;> simp +arith +decide [ Nat.add_div ] at *

/-
The function y(p, k) is injective for k in 1 to (p-3)/2.
-/
lemma y_inj (p : ℕ) [Fact p.Prime] (hp : p > 3) :
    Set.InjOn (y p) (Finset.Icc 1 ((p - 3) / 2)) := by
  -- Suppose $y_a = y_b$ for $a, b \in \{1, \dots, (p-3)/2\}$.
  intro a ha b hb hab
  have h_eq : (a : ZMod p) * (a + 1) = (b : ZMod p) * (b + 1) := by
    unfold y at hab;
    rw [ ZMod.val_injective p |>.eq_iff ] at hab;
    grind;
  -- So $a \equiv b$ or $a+b+1 \equiv 0$.
  have h_cases : (a : ZMod p) = (b : ZMod p) ∨ (a : ZMod p) + (b : ZMod p) + 1 = 0 := by
    exact Classical.or_iff_not_imp_left.2 fun h => mul_left_cancel₀ ( sub_ne_zero_of_ne h ) <| by linear_combination' h_eq;
  aesop;
  · exact Nat.mod_eq_of_lt ( show a < p from by omega ) ▸ Nat.mod_eq_of_lt ( show b < p from by omega ) ▸ by simpa [ ← ZMod.natCast_eq_natCast_iff' ] using h;
  · norm_cast at h_1;
    rw [ ZMod.natCast_eq_zero_iff ] at h_1 ; linarith [ Nat.le_of_dvd ( by linarith ) h_1, Nat.div_mul_le_self ( p - 3 ) 2, Nat.sub_add_cancel ( by linarith : 3 ≤ p ) ]

/-
S(p) is congruent to 2 modulo p.
-/
lemma S_mod_p (p : ℕ) [Fact p.Prime] (hp : p > 3) : S p ≡ 2 [ZMOD p] := by
  -- Let's rewrite the sum $S$ using the identity $y(p, k) = \frac{1}{k} - \frac{1}{k+1}$.
  have h_sum : ∑ k ∈ Finset.Icc 1 (p - 2), (y p k : ZMod p) = ∑ k ∈ Finset.Icc 1 (p - 2), ((k : ZMod p)⁻¹ - ((k + 1) : ZMod p)⁻¹) := by
    unfold y;
    rw [ Finset.sum_congr rfl ] ; intros ; aesop;
    rw [ inv_sub_inv ] <;> ring <;> norm_num;
    · rw [ ← mul_inv ] ; ring;
    · rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt left ( right.trans_lt ( Nat.sub_lt ( by linarith ) ( by linarith ) ) );
    · norm_cast;
      rw [ ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by linarith ) ( by linarith [ Nat.sub_add_cancel ( by linarith : 2 ≤ p ) ] );
  -- Let's rewrite the sum $\sum_{k=1}^{p-2} (k^{-1} - (k+1)^{-1})$ as a telescoping series.
  have h_telescope : ∑ k ∈ Finset.Icc 1 (p - 2), ((k : ZMod p)⁻¹ - ((k + 1) : ZMod p)⁻¹) = (1 : ZMod p) - ((p - 1) : ZMod p)⁻¹ := by
    erw [ Finset.sum_Ico_eq_sum_range ];
    convert Finset.sum_range_sub' _ _ using 3 <;> norm_num [ add_comm, Nat.cast_sub ( show 2 ≤ p by linarith ) ];
  norm_num [ ← ZMod.intCast_eq_intCast_iff, S ] at * ; aesop;

/-
The sum of y(p, k) for k from 1 to (p-3)/2 is at most (3p^2 - 12p + 33) / 8.
-/
lemma sum_le_max_sum (p : ℕ) [Fact p.Prime] (hp : p > 13) :
    ∑ k ∈ Finset.Icc 1 ((p - 3) / 2), y p k ≤ (3 * p^2 - 12 * p + 33) / 8 := by
  have h_max_sum : ∀ S : Finset ℕ, S.card = (p - 3) / 2 → (∀ x ∈ S, 1 ≤ x ∧ x < p) → (∀ x ∈ S, x ≠ p - 4) → ∑ x ∈ S, x ≤ (3 * p^2 - 12 * p + 33) / 8 := by
    intros S hS_card hS_bounds hS_ne_p_minus_4
    have h_max_sum : ∑ x ∈ S, x ≤ ∑ x ∈ Finset.Icc 1 (p - 1) \ {p - 4}, x - ∑ x ∈ Finset.Icc 1 (p - 1) \ (S ∪ {p - 4}), x := by
      rw [ Nat.sub_eq_of_eq_add ];
      rw [ ← Finset.sum_union ];
      · rcongr x ; by_cases hx : x ∈ S <;> aesop;
        exact Nat.le_sub_one_of_lt ( hS_bounds x hx |>.2 );
      · exact Finset.disjoint_left.mpr fun x hxS hx => by aesop;
    -- The sum of the elements in Finset.Icc 1 (p - 1) \ {p - 4} is (p - 1) * p / 2 - (p - 4).
    have h_sum_complement : ∑ x ∈ Finset.Icc 1 (p - 1) \ {p - 4}, x = (p - 1) * p / 2 - (p - 4) := by
      have h_sum_complement : ∑ x ∈ Finset.Icc 1 (p - 1), x = (p - 1) * p / 2 := by
        exact Eq.symm ( Nat.div_eq_of_eq_mul_left zero_lt_two ( Nat.recOn p ( by norm_num ) fun n hn => by cases n <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] at * ; linarith ) );
      rw [ ← h_sum_complement, Finset.sum_eq_sum_diff_singleton_add ( show p - 4 ∈ Finset.Icc 1 ( p - 1 ) from Finset.mem_Icc.mpr ⟨ Nat.le_sub_of_add_le ( by linarith ), Nat.sub_le_sub_left ( by linarith ) _ ⟩ ), add_tsub_cancel_right ];
    -- The sum of the elements in Finset.Icc 1 (p - 1) \ (S ∪ {p - 4}) is at least the sum of the first (p - 1) - ((p - 3) / 2 + 1) natural numbers.
    have h_sum_first : ∑ x ∈ Finset.Icc 1 (p - 1) \ (S ∪ {p - 4}), x ≥ ∑ x ∈ Finset.range ((p - 1) - ((p - 3) / 2 + 1)), (x + 1) := by
      have h_sum_first : Finset.card (Finset.Icc 1 (p - 1) \ (S ∪ {p - 4})) = (p - 1) - ((p - 3) / 2 + 1) := by
        rw [ Finset.card_sdiff ] ; norm_num [ Finset.subset_iff, hS_card ];
        rw [ show Insert.insert ( p - 4 ) S ∩ Finset.Icc 1 ( p - 1 ) = Insert.insert ( p - 4 ) S from ?_, Finset.card_insert_of_notMem ] <;> norm_num [ hS_card ];
        · exact fun h => hS_ne_p_minus_4 _ h rfl;
        · exact Finset.insert_subset_iff.mpr ⟨ Finset.mem_Icc.mpr ⟨ Nat.le_sub_of_add_le ( by linarith ), Nat.sub_le_sub_left ( by linarith ) _ ⟩, fun x hx => Finset.mem_Icc.mpr ⟨ hS_bounds x hx |>.1, Nat.le_sub_one_of_lt ( hS_bounds x hx |>.2 ) ⟩ ⟩;
      -- Since Finset.Icc 1 (p - 1) \ (S ∪ {p - 4}) is a subset of {1, 2, ..., p - 1} with cardinality (p - 1) - ((p - 3) / 2 + 1), we can order its elements.
      obtain ⟨f, hf⟩ : ∃ f : Fin ((p - 1) - ((p - 3) / 2 + 1)) → ℕ, StrictMono f ∧ ∀ i, f i ∈ Finset.Icc 1 (p - 1) \ (S ∪ {p - 4}) := by
        exact ⟨ fun i => Finset.orderEmbOfFin _ ( by aesop ) i, by aesop_cat, fun i => Finset.orderEmbOfFin_mem _ ( by aesop ) _ ⟩;
      -- Since $f$ is strictly monotone, we have $f i ≥ i + 1$ for all $i$.
      have h_f_ge : ∀ i, f i ≥ i + 1 := by
        intro i; induction i; aesop;
        induction' val with val ih;
        · linarith [ right ⟨ 0, isLt ⟩ ];
        · exact lt_of_le_of_lt ( ih ( Nat.lt_of_succ_lt isLt ) ) ( left ( Nat.lt_succ_self _ ) );
      have h_sum_ge : ∑ x ∈ Finset.image f Finset.univ, x ≥ ∑ x ∈ Finset.range ((p - 1) - ((p - 3) / 2 + 1)), (x + 1) := by
        rw [ Finset.sum_image <| by intros i hi j hj hij; exact hf.1.injective hij ] ; rw [ Finset.sum_range ] ; exact Finset.sum_le_sum fun i _ => h_f_ge i;
      exact h_sum_ge.trans ( Finset.sum_le_sum_of_subset <| Finset.image_subset_iff.mpr fun i _ => hf.2 i );
    -- The sum of the first (p - 1) - ((p - 3) / 2 + 1) natural numbers is ((p - 1) - ((p - 3) / 2 + 1)) * ((p - 1) - ((p - 3) / 2 + 1) + 1) / 2.
    have h_sum_first_formula : ∑ x ∈ Finset.range ((p - 1) - ((p - 3) / 2 + 1)), (x + 1) = ((p - 1) - ((p - 3) / 2 + 1)) * ((p - 1) - ((p - 3) / 2 + 1) + 1) / 2 := by
      convert Finset.sum_range_id ( p - 1 - ( ( p - 3 ) / 2 + 1 ) + 1 ) using 1 <;> simp +arith +decide [ mul_comm, Finset.sum_range_succ' ];
    rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num at *;
    · exact absurd ( Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime ( 2 * c ) ) ) ( by omega );
    · rcases c with ( _ | _ | c ) <;> simp +arith +decide [ Nat.mul_succ, Nat.add_mul_div_left ] at *;
      norm_num [ show 2 * c + 2 - c = c + 2 by rw [ Nat.sub_eq_of_eq_add ] ; ring ] at *;
      refine le_trans h_max_sum ?_;
      rw [ h_sum_complement ];
      rw [ tsub_tsub, tsub_le_iff_left ];
      rw [ Nat.div_le_iff_le_mul_add_pred ] <;> norm_num;
      nlinarith only [ hp, h_sum_first, h_sum_first_formula, Nat.div_mul_cancel ( show 2 ∣ ( c + 2 ) * ( c + 2 ) + ( c + 2 ) from even_iff_two_dvd.mp ( by simp +arith +decide [ mul_add, parity_simps ] ) ), Nat.div_add_mod ( 3 * ( 2 * c + 5 ) ^ 2 - ( 24 * c + 60 ) + 33 ) 8, Nat.mod_lt ( 3 * ( 2 * c + 5 ) ^ 2 - ( 24 * c + 60 ) + 33 ) ( by decide : 0 < 8 ), Nat.sub_add_cancel ( show 24 * c + 60 ≤ 3 * ( 2 * c + 5 ) ^ 2 from by nlinarith only [ hp ] ) ];
  convert h_max_sum ( Finset.image ( y p ) ( Finset.Icc 1 ( ( p - 3 ) / 2 ) ) ) _ _ _ using 1;
  · rw [ Finset.sum_image ];
    exact y_inj p ( by linarith );
  · rw [ Finset.card_image_of_injOn, Nat.card_Icc ];
    · rfl;
    · exact y_inj p ( by linarith );
  · simp +zetaDelta at *;
    rintro _ k hk₁ hk₂ rfl; unfold y; aesop;
    · contrapose! hk₁; aesop;
      · norm_cast at h;
        rw [ ZMod.natCast_eq_zero_iff ] at h ; linarith [ Nat.le_of_dvd ( Nat.succ_pos _ ) h, Nat.div_mul_le_self ( p - 3 ) 2, Nat.sub_add_cancel ( by linarith : 3 ≤ p ) ];
      · rw [ ZMod.natCast_eq_zero_iff ] at h_1 ; exact Nat.eq_zero_of_dvd_of_lt h_1 ( by omega );
    · exact ZMod.val_lt _;
  · -- By definition of $y$, we know that $y p k = (k * (k + 1))⁻¹$ in $ZMod p$. If $y p k = p - 4$, then $k * (k + 1) ≡ 1/(p - 4) [ZMOD p]$.
    have h_contra : ∀ k ∈ Finset.Icc 1 ((p - 3) / 2), y p k ≠ p - 4 := by
      intro k hk
      by_contra h_contra
      have h_eq : k * (k + 1) * (p - 4) ≡ 1 [MOD p] := by
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
        unfold y at h_contra;
        rw [ ← h_contra, ZMod.natCast_zmod_val ];
        rw [ mul_inv_cancel₀ ] ; aesop;
        · omega;
        · omega;
      -- If $k * (k + 1) * (p - 4) ≡ 1 [MOD p]$, then $k * (k + 1) * (-4) ≡ 1 [MOD p]$, which simplifies to $4k^2 + 4k + 1 ≡ 0 [MOD p]$.
      have h_simplified : 4 * k^2 + 4 * k + 1 ≡ 0 [MOD p] := by
        simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, Nat.cast_sub ( show 4 ≤ p by linarith ) ];
        linear_combination' -h_eq;
      -- Since $p$ is prime and $p \mid (2k + 1)^2$, it must divide $2k + 1$.
      have h_div : p ∣ (2 * k + 1) := by
        exact Nat.Prime.dvd_of_dvd_pow ( Fact.out : Nat.Prime p ) ( by rw [ show ( 2 * k + 1 ) ^ 2 = 4 * k ^ 2 + 4 * k + 1 by ring ] ; exact Nat.dvd_of_mod_eq_zero h_simplified );
      linarith [ Nat.le_of_dvd ( Nat.succ_pos _ ) h_div, Finset.mem_Icc.mp hk, Nat.div_mul_le_self ( p - 3 ) 2, Nat.sub_add_cancel ( by linarith : 3 ≤ p ) ];
    aesop

/-
S(p) is at most (3p^2 - 8p + 17) / 4 for p > 13.
-/
lemma S_bound (p : ℕ) [Fact p.Prime] (hp : p > 13) :
    S p ≤ (3 * p^2 - 8 * p + 17) / 4 := by
  -- Using `sum_le_max_sum`, $\sum_{k=1}^{(p-3)/2} y_k \le \frac{3p^2-12p+33}{8}$.
  have h_sum_le_max_sum : ∑ k ∈ Finset.Icc 1 ((p - 3) / 2), y p k ≤ (3 * p ^ 2 - 12 * p + 33) / 8 := by
    exact?;
  rw [ Nat.le_div_iff_mul_le ] at * <;> norm_num;
  rw [ show S p = 2 * ∑ k ∈ Finset.Icc 1 ( ( p - 3 ) / 2 ), y p k + y p ( ( p - 1 ) / 2 ) by exact S_decomp p <| by linarith ];
  rw [ y_mid ];
  · zify at *;
    rw [ Nat.cast_sub, Nat.cast_sub ] at * <;> push_cast at * <;> nlinarith only [ hp, h_sum_le_max_sum ] ;
  · exact?

/-
If p = 1 mod 4 and p > 13, then the bound holds.
-/
lemma algebra_lemma_mod_1 (p k : ℕ) (hp : p > 13) (h_mod : p % 4 = 1) (h : 4 * (k - 1) * p + 8 ≤ 3 * p^2 - 8 * p + 17) :
    k ≤ p - 2 - p / 4 := by
  rcases k with ( _ | _ | k ) <;> norm_num at *;
  · omega;
  · rw [ tsub_tsub, Nat.le_sub_iff_add_le ];
    · nlinarith [ Nat.mod_add_div p 4, Nat.sub_add_cancel ( show 8 * p ≤ 3 * p ^ 2 by nlinarith ) ];
    · omega

/-
If p = 3 mod 4 and p > 13, then the bound holds.
-/
lemma algebra_lemma_mod_3 (p k : ℕ) (hp : p > 13) (h_mod : p % 4 = 3) (h : 4 * (k - 1) * p + 8 ≤ 3 * p^2 - 8 * p + 17) :
    k ≤ p - 2 - p / 4 := by
  -- Since $p \equiv 3 \pmod{4}$, let $p = 4m + 3$.
  obtain ⟨m, rfl⟩ : ∃ m, p = 4 * m + 3 := by
    exact ⟨ p / 4, by rw [ ← h_mod, Nat.div_add_mod p 4 ] ⟩;
  -- We want to show $k-1 \le 3m$.
  suffices h_k_le : k - 1 ≤ 3 * m by
    omega;
  contrapose! h;
  zify;
  rw [ Nat.cast_sub ] <;> push_cast <;> nlinarith only [ h, hp ]

/-
Algebraic lemma: if 4(k-1)p + 8 <= 3p^2 - 8p + 17 and p > 13, then k <= p - 2 - p/4.
-/
lemma algebra_lemma (p k : ℕ) [Fact p.Prime] (hp : p > 13) (h : 4 * (k - 1) * p + 8 ≤ 3 * p^2 - 8 * p + 17) :
    k ≤ p - 2 - p / 4 := by
      -- Since $p > 13$ is prime, $p$ is odd, so $p \equiv 1, 3 \pmod 4$.
      by_cases hp_mod : p % 4 = 1 ∨ p % 4 = 3;
      · bound;
        · exact?;
        · exact?;
      · have := Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) ; omega;

/-
Algebraic lemma: if 4(k-1)p + 8 <= 3p^2 - 8p + 17 and p > 13, then k <= p - 2 - p/4.
-/
lemma algebra_lemma_final (p k : ℕ) [h : Fact p.Prime] (hp : p > 13) (h_ineq : 4 * (k - 1) * p + 8 ≤ 3 * p^2 - 8 * p + 17) :
    k ≤ p - 2 - p / 4 := by
      -- Apply the algebraic lemma to conclude the proof.
      apply algebra_lemma p k hp h_ineq

/-
The number of descents is greater than p/4 - 1 for p > 13.
-/
lemma count_inv_descents_large (p : ℕ) [Fact p.Prime] (hp : p > 13) :
    (descents p).card > p / 4 - 1 := by
      -- Let $k = \frac{S + p - 2}{p}$. We know that $S \equiv 2 \pmod{p}$, so $S = (k-1)p + 2$.
      obtain ⟨k, hk⟩ : ∃ k, S p + p - 2 = k * p ∧ k = (S p + p - 2) / p := by
        refine' ⟨ _, Eq.symm ( Nat.div_mul_cancel _ ), rfl ⟩;
        have h_sum_mod : S p ≡ 2 [MOD p] := by
          simpa [ ← Int.natCast_modEq_iff ] using S_mod_p p ( by linarith );
        rw [ ← Nat.modEq_zero_iff_dvd ];
        cases le_total ( S p + p ) 2 <;> simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
      -- By `algebra_lemma_final`, this implies $k \le p - 2 - p/4$.
      have hk_le : k ≤ p - 2 - p / 4 := by
        have hk_le : 4 * (k - 1) * p + 8 ≤ 3 * p^2 - 8 * p + 17 := by
          have h_bound : S p ≤ (3 * p^2 - 8 * p + 17) / 4 := by
            exact?;
          rcases k with ( _ | _ | k ) <;> norm_num at *;
          grind;
        exact?;
      -- Then $|D| = p - 2 - k \ge p/4 > p/4 - 1$.
      have h_card : (descents p).card = p - 2 - k := by
        rw [ card_descents_eq p ( by linarith ) ];
        rw [ hk.2 ];
      omega

/-
The number of descents is greater than p/4 - 1.
-/
theorem count_inv_descents (p : ℕ) [Fact p.Prime] (hp : p > 3) :
    (descents p).card > p / 4 - 1 := by
      -- We split the proof into two cases: $p > 13$ and $p \le 13$.
      by_cases h_case : p > 13;
      · exact?;
      · interval_cases p <;> simp_all +decide only
        · native_decide;
        · native_decide;
        · native_decide;
        · native_decide
