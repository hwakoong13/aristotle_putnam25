/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0a0bf4f8-10db-4a2b-b452-1b82df44ac2e
-/

/-
We determine the minimal dimension k such that there exist k-by-k real matrices A_1,...,A_2025 satisfying the cycle commutation relations. We prove that k=3.
-/

import Mathlib

open scoped Classical

set_option maxHeartbeats 0

noncomputable section

open Matrix

def cycle_adj (n : ℕ) (i j : Fin n) : Prop :=
  (i.val + 1) % n = j.val ∨ (j.val + 1) % n = i.val

def is_cycle_commutation (n k : ℕ) (A : Fin n → Matrix (Fin k) (Fin k) ℝ) : Prop :=
  ∀ i j, Commute (A i) (A j) ↔ i = j ∨ cycle_adj n i j

noncomputable def min_cycle_commutation_dim (n : ℕ) : ℕ :=
  sInf {k | ∃ A, is_cycle_commutation n k A}

/-
Transitivity of commutation for 2x2 matrices, provided the middle one is not scalar.
-/
lemma commute_transitive_of_nonscalar_two {A B C : Matrix (Fin 2) (Fin 2) ℝ}
    (hB : ¬ ∃ c : ℝ, B = c • (1 : Matrix (Fin 2) (Fin 2) ℝ))
    (hAB : Commute A B) (hBC : Commute B C) : Commute A C := by
  unfold Commute at *;
  simp_all +decide [ SemiconjBy, Fin.forall_fin_two ];
  simp_all +decide [ ← Matrix.ext_iff, Fin.forall_fin_two, Matrix.mul_apply ];
  grind

/-
Dimension 1 is impossible for n >= 4.
-/
lemma dim_ne_one (n : ℕ) (h : n ≥ 4) : ¬ ∃ A, is_cycle_commutation n 1 A := by
  norm_num [ Commute ];
  intro A hA
  have h_comm : ∀ i j, Commute (A i) (A j) := by
    exact fun i j => by ext x y; fin_cases x; fin_cases y; simp +decide [ Matrix.mul_apply, mul_comm ] ;
  have := hA ⟨ 0, by linarith ⟩ ⟨ 2, by linarith ⟩ ; simp_all +decide;
  rcases n with ( _ | _ | _ | _ | n ) <;> norm_num [ Fin.ext_iff, Nat.mod_eq_of_lt ] at *;
  · contradiction;
  · contradiction;
  · contradiction;
  · contradiction;
  · cases this <;> norm_num [ Nat.mod_eq_of_lt ] at *

/-
0 is not adjacent to 2 in C_n for n >= 4.
-/
lemma cycle_adj_0_2_false (n : ℕ) (h : n ≥ 4) : ¬ cycle_adj n ⟨0, by
  linarith⟩ ⟨2, by
  grind⟩ := by
  unfold cycle_adj; aesop;
  · rw [ Nat.mod_eq_of_lt ] at a <;> linarith;
  · rw [ Nat.mod_eq_of_lt ] at a <;> linarith

/-
i is not adjacent to i+2 in C_n for n >= 4.
-/
lemma cycle_adj_i_i_plus_2_false (n : ℕ) (h : n ≥ 4) (i : Fin n) :
    ¬ cycle_adj n i ⟨(i.val + 2) % n, Nat.mod_lt _ (by
    grind)⟩ := by
      unfold cycle_adj; aesop;
      · have := Nat.modEq_iff_dvd.1 a.symm; norm_num at this; norm_cast at this; aesop;
      · have := Nat.mod_add_div ( ( i : ℕ ) + 2 + 1 ) n; aesop;
        nlinarith [ show ( ( i : ℕ ) + 2 + 1 ) / n = 1 by nlinarith ]

/-
No matrix in a dimension 2 cycle commutation representation is scalar.
-/
lemma no_scalar_in_dim_two (n : ℕ) (h : n ≥ 4) (A : Fin n → Matrix (Fin 2) (Fin 2) ℝ)
    (hA : is_cycle_commutation n 2 A) (i : Fin n) : ¬ ∃ c : ℝ, A i = c • (1 : Matrix (Fin 2) (Fin 2) ℝ) := by
      intro ⟨ c, hc ⟩;
      have := hA i ( ⟨ ( i + 2 ) % n, Nat.mod_lt _ ( by linarith ) ⟩ : Fin n ) ; simp_all +decide [ Commute, mul_comm ];
      contrapose! this;
      refine Or.inl ⟨ ?_, ?_, ?_ ⟩;
      · simp +decide [ SemiconjBy, mul_smul_comm ];
      · intro H; have := congr_arg Fin.val H; norm_num at this;
        -- Since $i = (i + 2) \mod n$, we have $n \mid 2$, which contradicts $n \geq 4$.
        have h_contra : n ∣ 2 := by
          exact ⟨ ( i + 2 ) / n, by linarith [ Nat.mod_add_div ( i + 2 ) n ] ⟩;
        linarith [ Nat.le_of_dvd ( by decide ) h_contra ];
      · exact?

/-
Dimension 2 is impossible for n >= 4.
-/
lemma dim_ne_two (n : ℕ) (h : n ≥ 4) : ¬ ∃ A, is_cycle_commutation n 2 A := by
  bound;
  -- Since $A_1$ is not scalar, and $A_0$ commutes with $A_1$, and $A_1$ commutes with $A_2$, by transitivity $A_0$ must commute with $A_2$.
  have h_trans : Commute (w ⟨0, by
    linarith⟩) (w ⟨2, by
    grind⟩) := by
    convert commute_transitive_of_nonscalar_two _ _ _ using 1;
    exact w ⟨ 1, by linarith ⟩;
    generalize_proofs at *
    · exact?;
    · apply (h_1 ⟨0, by linarith⟩ ⟨1, by linarith⟩).mpr;
      exact Or.inr ( Or.inl <| by norm_num [ Nat.mod_eq_of_lt ( by linarith : 1 < n ) ] );
    · have := h_1 ⟨ 1, by linarith ⟩ ⟨ 2, by linarith ⟩ ; aesop;
      exact Or.inl ( by norm_num [ Nat.mod_eq_of_lt ( by linarith : 1 + 1 < n ) ] )
  generalize_proofs at *;
  have := h_1 ⟨ 0, by linarith ⟩ ⟨ 2, by linarith ⟩ ; simp_all +decide [ commute_iff_eq ] ;
  exact absurd this ( by exact? )

/-
Definition of orthogonal representation of C_n in R^3.
-/
def ortho_dot (v w : Fin 3 → ℝ) : ℝ := Finset.sum Finset.univ (fun k => v k * w k)

def is_ortho_cycle_rep (n : ℕ) (v : Fin n → Fin 3 → ℝ) : Prop :=
  (∀ i, v i ≠ 0) ∧
  (∀ i j, ortho_dot (v i) (v j) = 0 ↔ cycle_adj n i j)

/-
Rank 1 matrices commute iff vectors are orthogonal or parallel.
-/
open Matrix

def rank_one_matrix (v : Fin 3 → ℝ) : Matrix (Fin 3) (Fin 3) ℝ := vecMulVec v v

lemma rank_one_commute_iff (v w : Fin 3 → ℝ) (hv : v ≠ 0) (hw : w ≠ 0) :
    Commute (rank_one_matrix v) (rank_one_matrix w) ↔
    ortho_dot v w = 0 ∨ ∃ c : ℝ, v = c • w := by
  unfold rank_one_matrix; aesop;
  · -- If $v \cdot w = 0$, then we are done. Otherwise, we can divide both sides by $v \cdot w$ to get $v w^T = w v^T$.
    by_cases h_dot : ortho_dot v w = 0;
    · exact Or.inl h_dot;
    · -- If $v \cdot w \neq 0$, then we can divide both sides by $v \cdot w$ to get $v w^T = w v^T$, which implies $v$ and $w$ are proportional.
      have h_prop : ∀ i j, v i * w j = w i * v j := by
        unfold ortho_dot at h_dot;
        simp_all +decide [ SemiconjBy, Matrix.vecMulVec ];
        intro i j; have := congr_fun ( congr_fun a i ) j; simp_all +decide [ Matrix.mul_apply, Fin.sum_univ_three ];
        exact mul_left_cancel₀ h_dot <| by linarith;
      -- If $v \cdot w \neq 0$, then we can divide both sides by $v \cdot w$ to get $v w^T = w v^T$, which implies $v$ and $w$ are proportional. Hence, there exists a scalar $c$ such that $v = c • w$.
      obtain ⟨c, hc⟩ : ∃ c : ℝ, ∀ i, v i = c * w i := by
        obtain ⟨i, hi⟩ : ∃ i, w i ≠ 0 := by
          exact Function.ne_iff.mp hw;
        exact ⟨ v i / w i, fun j => by rw [ div_mul_eq_mul_div, eq_div_iff hi ] ; linarith [ h_prop i j ] ⟩;
      exact Or.inr ⟨ c, funext hc ⟩;
  · ext i j; simp +decide [ Commute, Matrix.vecMulVec, h ] ;
    unfold ortho_dot at h; simp_all +decide [ Matrix.mul_apply, Fin.sum_univ_three ] ;
    grind +ring

/-
For n >= 5, vertices with the same neighbors in C_n are identical.
-/
lemma cycle_neighborhood_inj (n : ℕ) (h : n ≥ 5) (i j : Fin n)
    (h_eq : ∀ k, cycle_adj n i k ↔ cycle_adj n j k) : i = j := by
  -- Neighbors of i are {i-1, i+1}
  -- Neighbors of j are {j-1, j+1}
  -- {i-1, i+1} = {j-1, j+1}
  -- Either (i-1 = j-1 and i+1 = j+1) => i=j
  -- Or (i-1 = j+1 and i+1 = j-1) => i = j+2 and i = j-2 => j+2 = j-2 => 4 = 0 mod n => n | 4 => False
  unfold cycle_adj at h_eq; aesop;
  have := h_eq ⟨ ( i + 1 ) % n, Nat.mod_lt _ ( by linarith ) ⟩ ; specialize h_eq ⟨ ( j + 1 ) % n, Nat.mod_lt _ ( by linarith ) ⟩ ; aesop;
  · exact Fin.ext ( by have := Nat.modEq_iff_dvd.1 h_2.symm; norm_num at this; obtain ⟨ k, hk ⟩ := this; nlinarith [ show k = 0 by nlinarith [ Fin.is_lt i, Fin.is_lt j ] ] );
  · have := Nat.modEq_iff_dvd.mp h_1.symm; aesop;
    exact Fin.ext ( by obtain ⟨ k, hk ⟩ := this; nlinarith [ show k = 0 by nlinarith [ Fin.is_lt i, Fin.is_lt j ] ] );
  · have := Nat.modEq_iff_dvd.1 h_1.symm;
    exact Fin.ext ( by obtain ⟨ k, hk ⟩ := this; norm_num at hk; nlinarith [ show k = 0 by nlinarith [ Fin.is_lt i, Fin.is_lt j ] ] );
  · -- Adding the two equations $i + 2 = j + kn$ and $j + 2 = i + ln$ gives $4 = (k + l)n$. Since $n \geq 5$, this implies $k + l = 0$, so $i + 2 = j$ and $j + 2 = i$.
    have h_sum : (i + 2 : ℕ) = j + (i + 2 - j) / n * n ∧ (j + 2 : ℕ) = i + (j + 2 - i) / n * n := by
      bound;
      · rw [ Nat.div_mul_cancel ];
        · rw [ Nat.add_sub_of_le ( by linarith [ Nat.mod_le ( i + 1 + 1 ) n, Fin.is_lt j ] ) ];
        · rw [ ← Nat.mod_add_div ( i + 2 ) n, h_2 ] ; norm_num;
      · rw [ Nat.div_mul_cancel ];
        · rw [ add_tsub_cancel_of_le ( by linarith [ Nat.mod_le ( j + 1 + 1 ) n, Fin.is_lt i, Fin.is_lt j ] ) ];
        · rw [ ← Nat.mod_add_div ( ( j : ℕ ) + 2 ) n, h_3 ] ; norm_num [ Nat.add_mod, Nat.mod_eq_of_lt ];
    exact Fin.ext ( by nlinarith [ show ( ( i + 2 - j ) / n : ℕ ) + ( ( j + 2 - i ) / n : ℕ ) = 0 by nlinarith [ Fin.is_lt i, Fin.is_lt j ] ] )

/-
An orthogonal representation implies dimension <= 3.
-/
lemma dim_le_three_of_ortho_rep (n : ℕ) (h : n ≥ 5) (v : Fin n → Fin 3 → ℝ)
    (hv : is_ortho_cycle_rep n v) : min_cycle_commutation_dim n ≤ 3 := by
      -- For n >= 5, vertices with the same neighbors in C_n are identical. Therefore, v_i ≠ v_j for i ≠ j.
      have h_distinct : ∀ i j, i ≠ j → ¬∃ c : ℝ, v i = c • v j := by
        intro i j hij h
        have h_neighborhood : ∀ k, cycle_adj n i k ↔ cycle_adj n j k := by
          cases' h with c hc;
          intro k; have := hv.2 i k; have := hv.2 j k; simp_all +decide [ mul_comm ] ;
          unfold ortho_dot at *; simp_all +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm ] ;
          by_cases hc : c = 0 <;> simp_all +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul ];
          exact absurd ‹v i = 0› ( hv.1 i );
        exact hij ( cycle_neighborhood_inj n ‹_› i j h_neighborhood );
      exact csInf_le ⟨ 0, fun k hk => Nat.zero_le _ ⟩ ⟨ fun i => rank_one_matrix ( v i ), by
        intro i j;
        by_cases hij : i = j <;> specialize h_distinct i j <;> aesop;
        · have := rank_one_commute_iff ( v i ) ( v j ) ( hv.1 i ) ( hv.1 j ) ; aesop;
          exact hv.2 i j |>.1 a;
        · exact rank_one_commute_iff _ _ ( hv.1 i ) ( hv.1 j ) |>.2 <| Or.inl <| hv.2 i j |>.2 a ⟩

/-
An orthogonal representation implies dimension <= 3.
-/
lemma dim_le_three_of_ortho_rep_new (n : ℕ) (h : n ≥ 5) (v : Fin n → Fin 3 → ℝ)
    (hv : is_ortho_cycle_rep n v) : min_cycle_commutation_dim n ≤ 3 := by
      exact?

/-
The constructed vectors form a faithful orthogonal representation of C_n for odd n >= 3.
-/
open Real

noncomputable def cycle_rep_angle (n : ℕ) : ℝ := π * (n - 1) / n

noncomputable def cycle_rep_sin_sq (n : ℕ) : ℝ := 1 / (1 - cos (cycle_rep_angle n))

noncomputable def cycle_rep_cos_sq (n : ℕ) : ℝ := 1 - cycle_rep_sin_sq n

noncomputable def cycle_rep_vec (n : ℕ) (k : Fin n) : Fin 3 → ℝ :=
  let δ := cycle_rep_angle n
  let s := sqrt (cycle_rep_sin_sq n)
  let c := sqrt (cycle_rep_cos_sq n)
  ![s * cos (k * δ), s * sin (k * δ), c]

lemma cycle_rep_works (n : ℕ) (h_odd : Odd n) (h_ge_3 : n ≥ 3) :
    is_ortho_cycle_rep n (cycle_rep_vec n) := by
  -- By definition of cycle_rep_vec, we know that the dot product of v_i and v_j is zero if and only if i and j are adjacent.
  have h_dot_zero_iff_adjacent : ∀ i j : Fin n, ortho_dot (cycle_rep_vec n i) (cycle_rep_vec n j) = 0 ↔ cycle_adj n i j := by
    -- By definition of dot product, we know that if v i · v j = 0, then v i and v j are orthogonal. We need to show that this holds if and only if i and j are adjacent in the cycle.
    have h_dot_zero_iff_ortho (i j : Fin n) : ortho_dot (cycle_rep_vec n i) (cycle_rep_vec n j) = 0 ↔ Real.cos (Real.pi * (n - 1) / n * (i.val - j.val : ℝ)) = Real.cos (Real.pi * (n - 1) / n) := by
      unfold cycle_rep_vec ortho_dot; aesop;
      · simp_all +decide [ Fin.sum_univ_three, mul_sub ];
        rw [ Real.cos_sub ];
        unfold cycle_rep_sin_sq cycle_rep_cos_sq at *;
        unfold cycle_rep_sin_sq cycle_rep_angle at * ; ring_nf at * ; aesop;
        by_cases hn : n = 0 <;> aesop;
        rw [ Real.sq_sqrt, Real.sq_sqrt ] at * <;> try nlinarith [ Real.cos_sq' ( Real.pi * ( n : ℝ ) ⁻¹ ), Real.cos_le_one ( Real.pi * ( n : ℝ ) ⁻¹ ), inv_mul_cancel₀ ( show ( 1 + Real.cos ( Real.pi * ( n : ℝ ) ⁻¹ ) ) ≠ 0 from by nlinarith [ Real.cos_sq' ( Real.pi * ( n : ℝ ) ⁻¹ ), Real.cos_le_one ( Real.pi * ( n : ℝ ) ⁻¹ ), show 0 < Real.cos ( Real.pi * ( n : ℝ ) ⁻¹ ) from Real.cos_pos_of_mem_Ioo ⟨ by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( show ( n : ℝ ) ≠ 0 by positivity ) ], by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( show ( n : ℝ ) ≠ 0 by positivity ) ] ⟩ ] ) ];
        exact sub_nonneg_of_le ( inv_le_one_of_one_le₀ ( by linarith [ Real.cos_nonneg_of_mem_Icc ⟨ by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( show ( n : ℝ ) ≠ 0 by positivity ) ], show Real.pi * ( n : ℝ ) ⁻¹ ≤ Real.pi / 2 by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( show ( n : ℝ ) ≠ 0 by positivity ) ] ⟩ ] ) );
      · unfold cycle_rep_sin_sq cycle_rep_cos_sq cycle_rep_angle; norm_num [ Fin.sum_univ_succ ] ; ring_nf at *;
        norm_num [ show n ≠ 0 by linarith, cycle_rep_sin_sq ] at *;
        rw [ Real.sq_sqrt ];
        · rw [ Real.sq_sqrt ] <;> norm_num [ cycle_rep_angle ];
          · ring_nf at *;
            norm_num [ mul_assoc, mul_comm Real.pi _, ne_of_gt ( zero_lt_three.trans_le h_ge_3 ) ] at *;
            norm_num [ Real.cos_add, Real.sin_add ] at *;
            norm_num [ Real.cos_sub, Real.sin_sub ] at *;
            field_simp;
            rw [ add_div', add_div' ] <;> ring_nf at * <;> norm_num at *;
            · grind;
            · exact ne_of_gt ( add_pos_of_pos_of_nonneg zero_lt_one ( Real.cos_nonneg_of_mem_Icc ⟨ by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩ ) );
            · exact ne_of_gt ( add_pos_of_pos_of_nonneg zero_lt_one ( Real.cos_nonneg_of_mem_Icc ⟨ by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast, mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩ ) );
          · rw [ inv_eq_one_div, div_le_iff₀ ] <;> nlinarith [ Real.cos_sq' ( Real.pi * ( n - 1 ) / n ), show Real.cos ( Real.pi * ( n - 1 ) / n ) < 0 from Real.cos_neg_of_pi_div_two_lt_of_lt ( by rw [ lt_div_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast ] ) ( by rw [ div_lt_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( n : ℝ ) ≥ 3 by norm_cast ] ) ];
        · nlinarith [ Real.cos_sq' ( Real.pi * ( n : ℝ ) ⁻¹ ) ];
    -- We need to show that $\cos(\pi(n-1)/n(i-j)) = \cos(\pi(n-1)/n)$ if and only if $i$ and $j$ are adjacent in the cycle.
    have h_cos_eq_iff_adjacent (i j : Fin n) : Real.cos (Real.pi * (n - 1) / n * (i.val - j.val : ℝ)) = Real.cos (Real.pi * (n - 1) / n) ↔ ∃ k : ℤ, i.val - j.val = 1 + n * k ∨ i.val - j.val = -1 + n * k := by
      rw [ eq_comm, Real.cos_eq_cos_iff ];
      constructor <;> rintro ⟨ k, hk | hk ⟩;
      · -- By simplifying the equation, we can isolate the term involving $k$.
        have h_simplified : (n - 1) * (i.val - j.val - 1) = 2 * n * k := by
          exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( Real.pi * ( n - 1 ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( n - 1 : ℝ ) * ( i - j - 1 ) = 2 * n * k );
        -- Since $n$ is odd, we can divide both sides of the equation by $n$.
        have h_div : (n : ℤ) ∣ ((i.val - j.val - 1) : ℤ) := by
          have h_coprime : Int.gcd (n : ℤ) (n - 1) = 1 := by
            norm_num +zetaDelta at *;
          exact Int.dvd_of_dvd_mul_right_of_gcd_one ( h_simplified.symm ▸ dvd_mul_of_dvd_left ( dvd_mul_left _ _ ) _ ) h_coprime;
        exact Exists.elim h_div fun x hx => ⟨ x, Or.inl <| by linarith ⟩;
      · -- By simplifying $hk$, we can solve for $i - j$.
        field_simp at hk;
        norm_cast at hk;
        norm_num [ Int.subNatNat_eq_coe ] at hk;
        -- Rearrange hk to get $(n - 1)(i - j + 1) = 2nk$.
        have h_rearrange : (n - 1) * (i.val - j.val + 1 : ℤ) = 2 * n * k := by
          linarith;
        -- Since $n$ is odd, $n$ and $n-1$ are coprime, so $n$ must divide $(i - j + 1)$.
        have h_div : (n : ℤ) ∣ (i.val - j.val + 1 : ℤ) := by
          have h_coprime : Int.gcd (n : ℤ) (n - 1) = 1 := by
            simp +zetaDelta at *;
          exact Int.dvd_of_dvd_mul_right_of_gcd_one ( h_rearrange.symm ▸ dvd_mul_of_dvd_left ( dvd_mul_left _ _ ) _ ) h_coprime;
        exact Exists.elim h_div fun x hx => ⟨ x, Or.inr <| by linarith ⟩;
      · use k * ( n - 1 ) / 2;
        rw [ Int.cast_div ] <;> norm_num;
        · rw [ show ( i : ℝ ) - j = 1 + n * k by exact mod_cast hk ] ; ring_nf ; norm_num [ show n ≠ 0 by linarith ] ;
          exact Or.inl ( by simpa [ sq, mul_assoc, ne_of_gt ( zero_lt_three.trans_le h_ge_3 ) ] using by ring );
        · exact dvd_mul_of_dvd_right ( even_iff_two_dvd.mp ( by obtain ⟨ m, rfl ⟩ := h_odd; simp +arith +decide ) ) _;
      · use k * (n - 1) / 2;
        rw [ Int.cast_div ] <;> norm_num;
        · rw [ show ( i : ℝ ) - j = -1 + n * k by exact mod_cast hk ] ; ring_nf ; norm_num [ show n ≠ 0 by linarith ];
          norm_num [ sq, mul_assoc, ne_of_gt ( zero_lt_three.trans_le h_ge_3 ) ] ; ring_nf ; aesop;
        · exact dvd_mul_of_dvd_right ( even_iff_two_dvd.mp ( by obtain ⟨ m, rfl ⟩ := h_odd; simp +arith +decide [ parity_simps ] ) ) _;
    unfold cycle_adj; aesop;
    · right;
      rw [ Nat.ModEq.symm ];
      exact Nat.mod_eq_of_lt i.2;
      rw [ Nat.modEq_iff_dvd ];
      exact ⟨ -w, by push_cast; linarith ⟩;
    · norm_num [ show ( i : ℕ ) = n * w.toNat + j - 1 from eq_tsub_of_add_eq <| by nlinarith [ Int.toNat_of_nonneg ( by nlinarith [ Fin.is_lt i, Fin.is_lt j ] : 0 ≤ w ) ] ];
      rw [ Nat.sub_add_cancel ( by nlinarith [ Fin.is_lt i, Fin.is_lt j, Int.toNat_of_nonneg ( by nlinarith [ Fin.is_lt i, Fin.is_lt j ] : 0 ≤ w ) ] ) ] ; norm_num [ Nat.add_mod, Nat.mod_eq_of_lt ( show ( j : ℕ ) < n from j.2 ) ];
    · exact ⟨ ( i + 1 ) / n, Or.inr <| by linarith [ Nat.mod_add_div ( i + 1 ) n ] ⟩;
    · exact ⟨ - ( ( j + 1 ) / n ), Or.inl <| by push_cast; linarith [ Nat.mod_add_div ( j + 1 ) n ] ⟩;
  use fun i => ?_, fun i j => ?_;
  · intro H; specialize h_dot_zero_iff_adjacent i i; simp_all +decide [ ortho_dot ] ;
    unfold cycle_adj at h_dot_zero_iff_adjacent; aesop;
    have := Nat.mod_add_div ( i + 1 ) n; aesop;
  · exact h_dot_zero_iff_adjacent i j

/-
The minimum dimension is at most 3.
-/
lemma min_dim_le_three : min_cycle_commutation_dim 2025 ≤ 3 := by
  have h_ge_5 : 2025 ≥ 5 := by norm_num
  have h_odd : Odd 2025 := by decide
  apply dim_le_three_of_ortho_rep_new 2025 h_ge_5
  apply cycle_rep_works 2025 h_odd (by norm_num)

/-
Dimension 0 is impossible for n >= 4.
-/
lemma dim_ne_zero (n : ℕ) (h : n ≥ 4) : ¬ ∃ A, is_cycle_commutation n 0 A := by
  rintro ⟨ A, hA ⟩;
  have h_contra : ∀ i j : Fin n, i = j ∨ cycle_adj n i j := by
    exact fun i j => hA i j |>.1 ( by ext a b; fin_cases a );
  cases h_contra ⟨ 0, by linarith ⟩ ⟨ 2, by linarith ⟩ <;> simp_all +decide [ cycle_adj ];
  rcases n with ( _ | _ | _ | _ | n ) <;> simp_all +arith +decide [ Nat.mod_eq_of_lt ]

/-
There exists a cycle commutation representation of dimension 3 for n=2025.
-/
open Matrix Real

lemma exists_rep_three : ∃ A, is_cycle_commutation 2025 3 A := by
  use fun i => rank_one_matrix (cycle_rep_vec 2025 i);
  intros i j;
  constructor;
  · have := cycle_rep_works 2025 (by decide) (by decide);
    have := this.2 i j; aesop;
    have := rank_one_commute_iff ( cycle_rep_vec 2025 i ) ( cycle_rep_vec 2025 j ) ?_ ?_ <;> simp_all +decide [ Commute ];
    · unfold cycle_rep_vec at this; aesop;
      by_cases h : Real.sqrt ( cycle_rep_cos_sq 2025 ) = 0 <;> aesop;
      · unfold cycle_rep_cos_sq at h;
        unfold cycle_rep_sin_sq at h; norm_num at h;
        rw [ Real.sqrt_eq_zero' ] at h;
        rw [ sub_nonpos ] at h;
        rw [ inv_eq_one_div, le_div_iff₀ ] at h <;> norm_num [ cycle_rep_angle ] at *;
        · exact absurd h ( not_le_of_gt ( Real.cos_neg_of_pi_div_two_lt_of_lt ( by linarith [ Real.pi_pos ] ) ( by linarith [ Real.pi_pos ] ) ) );
        · nlinarith [ Real.sin_sq_add_cos_sq ( Real.pi * 2024 / 2025 ), Real.sin_pos_of_pos_of_lt_pi ( show 0 < Real.pi * 2024 / 2025 by positivity ) ( by linarith [ Real.pi_pos ] ) ];
      · -- Since $\cos(i \delta) = \cos(j \delta)$ and $\sin(i \delta) = \sin(j \delta)$, we have $i \delta = j \delta + 2k\pi$ for some integer $k$.
        obtain ⟨k, hk⟩ : ∃ k : ℤ, (i : ℝ) * cycle_rep_angle 2025 = (j : ℝ) * cycle_rep_angle 2025 + 2 * k * Real.pi := by
          rw [ Real.cos_eq_cos_iff, Real.sin_eq_sin_iff ] at * ; aesop;
          · exact ⟨ -w_1, by push_cast; ring ⟩;
          · exact ⟨ -w, by push_cast; ring ⟩;
          · exact ⟨ -w_1, by push_cast; linarith ⟩;
          · norm_cast at h_4; linarith [ show w_1 = w by linarith ] ;
        unfold cycle_rep_angle at hk; ring_nf at hk; norm_num at hk;
        -- Dividing both sides of the equation by $\pi$, we get $2024i = 2024j + 4050k$.
        have h_div : 2024 * (i : ℤ) = 2024 * (j : ℤ) + 4050 * k := by
          exact_mod_cast ( by nlinarith [ Real.pi_pos ] : ( 2024 : ℝ ) * i = 2024 * j + 4050 * k );
        omega;
      · unfold cycle_rep_sin_sq at h_3; norm_num at h_3;
        unfold cycle_rep_angle at h_3; norm_num at h_3;
        exact absurd h_3 <| ne_of_gt <| Real.sqrt_pos.mpr <| by nlinarith [ Real.cos_sq' <| Real.pi * 2024 / 2025, Real.sin_pos_of_pos_of_lt_pi ( show 0 < Real.pi * 2024 / 2025 by positivity ) <| by linarith [ Real.pi_pos ] ] ;
      · unfold cycle_rep_sin_sq at h_2; norm_num at h_2;
        rw [ Real.sqrt_eq_zero' ] at h_2;
        unfold cycle_rep_angle at h_2; norm_num at h_2;
        exact absurd h_2 ( not_le_of_gt ( by rw [ ← Real.cos_zero ] ; exact Real.cos_lt_cos_of_nonneg_of_le_pi ( by positivity ) ( by linarith [ Real.pi_pos ] ) ( by linarith [ Real.pi_pos ] ) ) );
      · unfold cycle_rep_sin_sq at h_3; norm_num at h_3;
        exact absurd h_3 <| ne_of_gt <| Real.sqrt_pos.mpr <| by nlinarith [ Real.cos_sq' <| cycle_rep_angle 2025, Real.sin_pos_of_pos_of_lt_pi ( show 0 < cycle_rep_angle 2025 by exact div_pos ( mul_pos Real.pi_pos <| sub_pos.mpr <| by norm_num ) <| by norm_num ) <| by unfold cycle_rep_angle; nlinarith [ Real.pi_pos ] ] ;
    · have := this_1.1 i; aesop;
    · have := this_1.1 j; aesop;
  · rintro ( rfl | h );
    · exact Commute.refl _;
    · have := cycle_rep_works 2025 ( by decide ) ( by decide );
      exact ( rank_one_commute_iff _ _ ( this.1 i ) ( this.1 j ) ) |>.2 ( Or.inl <| this.2 i j |>.2 h )

/-
The minimum dimension is 3.
-/
open Matrix Real

theorem answer : min_cycle_commutation_dim 2025 = 3 := by
  let S := {k | ∃ A, is_cycle_commutation 2025 k A}
  have h_nonempty : S.Nonempty := ⟨3, exists_rep_three⟩
  have h_min_mem : sInf S ∈ S := Nat.sInf_mem h_nonempty
  have h_le : sInf S ≤ 3 := min_dim_le_three
  have h_ge : sInf S ≥ 3 := by
    by_contra h_lt
    simp at h_lt
    interval_cases sInf S
    · apply dim_ne_zero 2025 (by norm_num)
      exact h_min_mem
    · apply dim_ne_one 2025 (by norm_num)
      exact h_min_mem
    · apply dim_ne_two 2025 (by norm_num)
      exact h_min_mem
  exact le_antisymm h_le h_ge
